{"ast":null,"code":"import { ref, computed, onMounted, onBeforeUnmount, defineComponent, h } from 'vue';\nimport { unwrapElement, beforeNextFrameOnce } from 'seemly';\nimport { useConfig, useStyle } from \"../../_mixins/index.mjs\";\nimport { warn, keysOf } from \"../../_utils/index.mjs\";\nimport { getScrollTop, getRect } from \"./utils.mjs\";\nimport style from \"./styles/index.cssr.mjs\";\nexport const affixProps = {\n  listenTo: [String, Object, Function],\n  top: Number,\n  bottom: Number,\n  triggerTop: Number,\n  triggerBottom: Number,\n  position: {\n    type: String,\n    default: 'fixed'\n  },\n  // deprecated\n  offsetTop: {\n    type: Number,\n    validator: () => {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('affix', '`offset-top` is deprecated, please use `trigger-top` instead.');\n      }\n      return true;\n    },\n    default: undefined\n  },\n  offsetBottom: {\n    type: Number,\n    validator: () => {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('affix', '`offset-bottom` is deprecated, please use `trigger-bottom` instead.');\n      }\n      return true;\n    },\n    default: undefined\n  },\n  target: {\n    type: Function,\n    validator: () => {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('affix', '`target` is deprecated, please use `listen-to` instead.');\n      }\n      return true;\n    },\n    default: undefined\n  }\n};\nexport const affixPropKeys = keysOf(affixProps);\nexport default defineComponent({\n  name: 'Affix',\n  props: affixProps,\n  setup(props) {\n    const {\n      mergedClsPrefixRef\n    } = useConfig(props);\n    useStyle('-affix', style, mergedClsPrefixRef);\n    let scrollTarget = null;\n    const stickToTopRef = ref(false);\n    const stickToBottomRef = ref(false);\n    const bottomAffixedTriggerScrollTopRef = ref(null);\n    const topAffixedTriggerScrollTopRef = ref(null);\n    const affixedRef = computed(() => {\n      return stickToBottomRef.value || stickToTopRef.value;\n    });\n    const mergedOffsetTopRef = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.triggerTop) !== null && _a !== void 0 ? _a : props.offsetTop) !== null && _b !== void 0 ? _b : props.top;\n    });\n    const mergedTopRef = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.top) !== null && _a !== void 0 ? _a : props.triggerTop) !== null && _b !== void 0 ? _b : props.offsetTop;\n    });\n    const mergedBottomRef = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.bottom) !== null && _a !== void 0 ? _a : props.triggerBottom) !== null && _b !== void 0 ? _b : props.offsetBottom;\n    });\n    const mergedOffsetBottomRef = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.triggerBottom) !== null && _a !== void 0 ? _a : props.offsetBottom) !== null && _b !== void 0 ? _b : props.bottom;\n    });\n    const selfRef = ref(null);\n    const init = () => {\n      const {\n        target: getScrollTarget,\n        listenTo\n      } = props;\n      if (getScrollTarget) {\n        // deprecated\n        scrollTarget = getScrollTarget();\n      } else if (listenTo) {\n        scrollTarget = unwrapElement(listenTo);\n      } else {\n        scrollTarget = document;\n      }\n      if (scrollTarget) {\n        scrollTarget.addEventListener('scroll', handleScroll);\n        handleScroll();\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('affix', 'Target to be listened to is not valid.');\n      }\n    };\n    function handleScroll() {\n      beforeNextFrameOnce(_handleScroll);\n    }\n    function _handleScroll() {\n      const {\n        value: selfEl\n      } = selfRef;\n      if (!scrollTarget || !selfEl) return;\n      const scrollTop = getScrollTop(scrollTarget);\n      if (affixedRef.value) {\n        if (topAffixedTriggerScrollTopRef.value !== null && scrollTop < topAffixedTriggerScrollTopRef.value) {\n          stickToTopRef.value = false;\n          topAffixedTriggerScrollTopRef.value = null;\n        }\n        if (bottomAffixedTriggerScrollTopRef.value !== null && scrollTop > bottomAffixedTriggerScrollTopRef.value) {\n          stickToBottomRef.value = false;\n          bottomAffixedTriggerScrollTopRef.value = null;\n        }\n        return;\n      }\n      const containerRect = getRect(scrollTarget);\n      const affixRect = selfEl.getBoundingClientRect();\n      const pxToTop = affixRect.top - containerRect.top;\n      const pxToBottom = containerRect.bottom - affixRect.bottom;\n      const mergedOffsetTop = mergedOffsetTopRef.value;\n      const mergedOffsetBottom = mergedOffsetBottomRef.value;\n      if (mergedOffsetTop !== undefined && pxToTop <= mergedOffsetTop) {\n        stickToTopRef.value = true;\n        topAffixedTriggerScrollTopRef.value = scrollTop - (mergedOffsetTop - pxToTop);\n      } else {\n        stickToTopRef.value = false;\n        topAffixedTriggerScrollTopRef.value = null;\n      }\n      if (mergedOffsetBottom !== undefined && pxToBottom <= mergedOffsetBottom) {\n        stickToBottomRef.value = true;\n        bottomAffixedTriggerScrollTopRef.value = scrollTop + mergedOffsetBottom - pxToBottom;\n      } else {\n        stickToBottomRef.value = false;\n        bottomAffixedTriggerScrollTopRef.value = null;\n      }\n    }\n    onMounted(() => {\n      init();\n    });\n    onBeforeUnmount(() => {\n      if (!scrollTarget) return;\n      scrollTarget.removeEventListener('scroll', handleScroll);\n    });\n    return {\n      selfRef,\n      affixed: affixedRef,\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedstyle: computed(() => {\n        const style = {};\n        if (stickToTopRef.value && mergedOffsetTopRef.value !== undefined && mergedTopRef.value !== undefined) {\n          style.top = `${mergedTopRef.value}px`;\n        }\n        if (stickToBottomRef.value && mergedOffsetBottomRef.value !== undefined && mergedBottomRef.value !== undefined) {\n          style.bottom = `${mergedBottomRef.value}px`;\n        }\n        return style;\n      })\n    };\n  },\n  render() {\n    const {\n      mergedClsPrefix\n    } = this;\n    return h(\"div\", {\n      ref: \"selfRef\",\n      class: [`${mergedClsPrefix}-affix`, {\n        [`${mergedClsPrefix}-affix--affixed`]: this.affixed,\n        [`${mergedClsPrefix}-affix--absolute-positioned`]: this.position === 'absolute'\n      }],\n      style: this.mergedstyle\n    }, this.$slots);\n  }\n});","map":{"version":3,"names":["ref","computed","onMounted","onBeforeUnmount","defineComponent","h","unwrapElement","beforeNextFrameOnce","useConfig","useStyle","warn","keysOf","getScrollTop","getRect","style","affixProps","listenTo","String","Object","Function","top","Number","bottom","triggerTop","triggerBottom","position","type","default","offsetTop","validator","process","env","NODE_ENV","undefined","offsetBottom","target","affixPropKeys","name","props","setup","mergedClsPrefixRef","scrollTarget","stickToTopRef","stickToBottomRef","bottomAffixedTriggerScrollTopRef","topAffixedTriggerScrollTopRef","affixedRef","value","mergedOffsetTopRef","_a","_b","mergedTopRef","mergedBottomRef","mergedOffsetBottomRef","selfRef","init","getScrollTarget","document","addEventListener","handleScroll","_handleScroll","selfEl","scrollTop","containerRect","affixRect","getBoundingClientRect","pxToTop","pxToBottom","mergedOffsetTop","mergedOffsetBottom","removeEventListener","affixed","mergedClsPrefix","mergedstyle","render","class","$slots"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/naive-ui/es/affix/src/Affix.mjs"],"sourcesContent":["import { ref, computed, onMounted, onBeforeUnmount, defineComponent, h } from 'vue';\nimport { unwrapElement, beforeNextFrameOnce } from 'seemly';\nimport { useConfig, useStyle } from \"../../_mixins/index.mjs\";\nimport { warn, keysOf } from \"../../_utils/index.mjs\";\nimport { getScrollTop, getRect } from \"./utils.mjs\";\nimport style from \"./styles/index.cssr.mjs\";\nexport const affixProps = {\n  listenTo: [String, Object, Function],\n  top: Number,\n  bottom: Number,\n  triggerTop: Number,\n  triggerBottom: Number,\n  position: {\n    type: String,\n    default: 'fixed'\n  },\n  // deprecated\n  offsetTop: {\n    type: Number,\n    validator: () => {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('affix', '`offset-top` is deprecated, please use `trigger-top` instead.');\n      }\n      return true;\n    },\n    default: undefined\n  },\n  offsetBottom: {\n    type: Number,\n    validator: () => {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('affix', '`offset-bottom` is deprecated, please use `trigger-bottom` instead.');\n      }\n      return true;\n    },\n    default: undefined\n  },\n  target: {\n    type: Function,\n    validator: () => {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('affix', '`target` is deprecated, please use `listen-to` instead.');\n      }\n      return true;\n    },\n    default: undefined\n  }\n};\nexport const affixPropKeys = keysOf(affixProps);\nexport default defineComponent({\n  name: 'Affix',\n  props: affixProps,\n  setup(props) {\n    const {\n      mergedClsPrefixRef\n    } = useConfig(props);\n    useStyle('-affix', style, mergedClsPrefixRef);\n    let scrollTarget = null;\n    const stickToTopRef = ref(false);\n    const stickToBottomRef = ref(false);\n    const bottomAffixedTriggerScrollTopRef = ref(null);\n    const topAffixedTriggerScrollTopRef = ref(null);\n    const affixedRef = computed(() => {\n      return stickToBottomRef.value || stickToTopRef.value;\n    });\n    const mergedOffsetTopRef = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.triggerTop) !== null && _a !== void 0 ? _a : props.offsetTop) !== null && _b !== void 0 ? _b : props.top;\n    });\n    const mergedTopRef = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.top) !== null && _a !== void 0 ? _a : props.triggerTop) !== null && _b !== void 0 ? _b : props.offsetTop;\n    });\n    const mergedBottomRef = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.bottom) !== null && _a !== void 0 ? _a : props.triggerBottom) !== null && _b !== void 0 ? _b : props.offsetBottom;\n    });\n    const mergedOffsetBottomRef = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.triggerBottom) !== null && _a !== void 0 ? _a : props.offsetBottom) !== null && _b !== void 0 ? _b : props.bottom;\n    });\n    const selfRef = ref(null);\n    const init = () => {\n      const {\n        target: getScrollTarget,\n        listenTo\n      } = props;\n      if (getScrollTarget) {\n        // deprecated\n        scrollTarget = getScrollTarget();\n      } else if (listenTo) {\n        scrollTarget = unwrapElement(listenTo);\n      } else {\n        scrollTarget = document;\n      }\n      if (scrollTarget) {\n        scrollTarget.addEventListener('scroll', handleScroll);\n        handleScroll();\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('affix', 'Target to be listened to is not valid.');\n      }\n    };\n    function handleScroll() {\n      beforeNextFrameOnce(_handleScroll);\n    }\n    function _handleScroll() {\n      const {\n        value: selfEl\n      } = selfRef;\n      if (!scrollTarget || !selfEl) return;\n      const scrollTop = getScrollTop(scrollTarget);\n      if (affixedRef.value) {\n        if (topAffixedTriggerScrollTopRef.value !== null && scrollTop < topAffixedTriggerScrollTopRef.value) {\n          stickToTopRef.value = false;\n          topAffixedTriggerScrollTopRef.value = null;\n        }\n        if (bottomAffixedTriggerScrollTopRef.value !== null && scrollTop > bottomAffixedTriggerScrollTopRef.value) {\n          stickToBottomRef.value = false;\n          bottomAffixedTriggerScrollTopRef.value = null;\n        }\n        return;\n      }\n      const containerRect = getRect(scrollTarget);\n      const affixRect = selfEl.getBoundingClientRect();\n      const pxToTop = affixRect.top - containerRect.top;\n      const pxToBottom = containerRect.bottom - affixRect.bottom;\n      const mergedOffsetTop = mergedOffsetTopRef.value;\n      const mergedOffsetBottom = mergedOffsetBottomRef.value;\n      if (mergedOffsetTop !== undefined && pxToTop <= mergedOffsetTop) {\n        stickToTopRef.value = true;\n        topAffixedTriggerScrollTopRef.value = scrollTop - (mergedOffsetTop - pxToTop);\n      } else {\n        stickToTopRef.value = false;\n        topAffixedTriggerScrollTopRef.value = null;\n      }\n      if (mergedOffsetBottom !== undefined && pxToBottom <= mergedOffsetBottom) {\n        stickToBottomRef.value = true;\n        bottomAffixedTriggerScrollTopRef.value = scrollTop + mergedOffsetBottom - pxToBottom;\n      } else {\n        stickToBottomRef.value = false;\n        bottomAffixedTriggerScrollTopRef.value = null;\n      }\n    }\n    onMounted(() => {\n      init();\n    });\n    onBeforeUnmount(() => {\n      if (!scrollTarget) return;\n      scrollTarget.removeEventListener('scroll', handleScroll);\n    });\n    return {\n      selfRef,\n      affixed: affixedRef,\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedstyle: computed(() => {\n        const style = {};\n        if (stickToTopRef.value && mergedOffsetTopRef.value !== undefined && mergedTopRef.value !== undefined) {\n          style.top = `${mergedTopRef.value}px`;\n        }\n        if (stickToBottomRef.value && mergedOffsetBottomRef.value !== undefined && mergedBottomRef.value !== undefined) {\n          style.bottom = `${mergedBottomRef.value}px`;\n        }\n        return style;\n      })\n    };\n  },\n  render() {\n    const {\n      mergedClsPrefix\n    } = this;\n    return h(\"div\", {\n      ref: \"selfRef\",\n      class: [`${mergedClsPrefix}-affix`, {\n        [`${mergedClsPrefix}-affix--affixed`]: this.affixed,\n        [`${mergedClsPrefix}-affix--absolute-positioned`]: this.position === 'absolute'\n      }],\n      style: this.mergedstyle\n    }, this.$slots);\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}