{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport { computed } from 'vue';\nimport { isBrowser } from \"../../_utils/index.mjs\";\nimport { happensIn } from 'seemly';\nexport function useMergedCheckStrategy(props) {\n  return computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n}\nexport function isNodeDisabled(node, disabledField) {\n  return !!node.rawNode[disabledField];\n}\nfunction traverse(nodes, childrenField, callback, callbackAfter) {\n  nodes === null || nodes === void 0 ? void 0 : nodes.forEach(node => {\n    callback(node);\n    traverse(node[childrenField], childrenField, callback, callbackAfter);\n    callbackAfter(node);\n  });\n}\nexport function keysWithFilter(nodes, pattern, keyField, childrenField, filter) {\n  const keys = new Set();\n  const highlightKeySet = new Set();\n  const path = [];\n  traverse(nodes, childrenField, node => {\n    path.push(node);\n    if (filter(pattern, node)) {\n      highlightKeySet.add(node[keyField]);\n      for (let i = path.length - 2; i >= 0; --i) {\n        if (!keys.has(path[i][keyField])) {\n          keys.add(path[i][keyField]);\n        } else {\n          return;\n        }\n      }\n    }\n  }, () => {\n    path.pop();\n  });\n  return {\n    expandedKeys: Array.from(keys),\n    highlightKeySet\n  };\n}\nconst emptyImage = null;\nif (isBrowser && Image) {\n  const emptyImage = new Image();\n  emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n}\nexport { emptyImage };\nexport function filterTree(tree, filter, pattern, keyField, childrenField) {\n  const visitedTailKeys = new Set();\n  const visitedNonTailKeys = new Set();\n  const highlightKeySet = new Set();\n  const expandedKeys = [];\n  const filteredTree = [];\n  const path = [];\n  function visit(t) {\n    t.forEach(n => {\n      path.push(n);\n      if (filter(pattern, n)) {\n        visitedTailKeys.add(n[keyField]);\n        highlightKeySet.add(n[keyField]);\n        for (let i = path.length - 2; i >= 0; --i) {\n          const key = path[i][keyField];\n          if (!visitedNonTailKeys.has(key)) {\n            visitedNonTailKeys.add(key);\n            if (visitedTailKeys.has(key)) {\n              visitedTailKeys.delete(key);\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      const children = n[childrenField];\n      if (children) {\n        visit(children);\n      }\n      path.pop();\n    });\n  }\n  visit(tree);\n  function build(t, sibs) {\n    t.forEach(n => {\n      const key = n[keyField];\n      const isVisitedTail = visitedTailKeys.has(key);\n      const isVisitedNonTail = visitedNonTailKeys.has(key);\n      if (!isVisitedTail && !isVisitedNonTail) return;\n      const children = n[childrenField];\n      if (children) {\n        if (isVisitedTail) {\n          // If it is visited path tail, use origin node\n          sibs.push(n);\n        } else {\n          // It it is not visited path tail, use cloned node\n          expandedKeys.push(key);\n          const clonedNode = Object.assign(Object.assign({}, n), {\n            [childrenField]: []\n          });\n          sibs.push(clonedNode);\n          build(children, clonedNode[childrenField]);\n        }\n      } else {\n        sibs.push(n);\n      }\n    });\n  }\n  build(tree, filteredTree);\n  return {\n    filteredTree,\n    highlightKeySet,\n    expandedKeys\n  };\n}\nexport function treeGetClickTarget(e) {\n  if (happensIn(e, 'checkbox')) {\n    return 'checkbox';\n  } else if (happensIn(e, 'switcher')) {\n    return 'switcher';\n  } else {\n    return 'node';\n  }\n}","map":{"version":3,"names":["computed","isBrowser","happensIn","useMergedCheckStrategy","props","leafOnly","checkStrategy","isNodeDisabled","node","disabledField","rawNode","traverse","nodes","childrenField","callback","callbackAfter","forEach","keysWithFilter","pattern","keyField","filter","keys","Set","highlightKeySet","path","push","add","i","length","has","pop","expandedKeys","Array","from","emptyImage","Image","src","filterTree","tree","visitedTailKeys","visitedNonTailKeys","filteredTree","visit","t","n","key","delete","children","build","sibs","isVisitedTail","isVisitedNonTail","clonedNode","Object","assign","treeGetClickTarget","e"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/naive-ui/es/tree/src/utils.mjs"],"sourcesContent":["import { computed } from 'vue';\nimport { isBrowser } from \"../../_utils/index.mjs\";\nimport { happensIn } from 'seemly';\nexport function useMergedCheckStrategy(props) {\n  return computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n}\nexport function isNodeDisabled(node, disabledField) {\n  return !!node.rawNode[disabledField];\n}\nfunction traverse(nodes, childrenField, callback, callbackAfter) {\n  nodes === null || nodes === void 0 ? void 0 : nodes.forEach(node => {\n    callback(node);\n    traverse(node[childrenField], childrenField, callback, callbackAfter);\n    callbackAfter(node);\n  });\n}\nexport function keysWithFilter(nodes, pattern, keyField, childrenField, filter) {\n  const keys = new Set();\n  const highlightKeySet = new Set();\n  const path = [];\n  traverse(nodes, childrenField, node => {\n    path.push(node);\n    if (filter(pattern, node)) {\n      highlightKeySet.add(node[keyField]);\n      for (let i = path.length - 2; i >= 0; --i) {\n        if (!keys.has(path[i][keyField])) {\n          keys.add(path[i][keyField]);\n        } else {\n          return;\n        }\n      }\n    }\n  }, () => {\n    path.pop();\n  });\n  return {\n    expandedKeys: Array.from(keys),\n    highlightKeySet\n  };\n}\nconst emptyImage = null;\nif (isBrowser && Image) {\n  const emptyImage = new Image();\n  emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n}\nexport { emptyImage };\nexport function filterTree(tree, filter, pattern, keyField, childrenField) {\n  const visitedTailKeys = new Set();\n  const visitedNonTailKeys = new Set();\n  const highlightKeySet = new Set();\n  const expandedKeys = [];\n  const filteredTree = [];\n  const path = [];\n  function visit(t) {\n    t.forEach(n => {\n      path.push(n);\n      if (filter(pattern, n)) {\n        visitedTailKeys.add(n[keyField]);\n        highlightKeySet.add(n[keyField]);\n        for (let i = path.length - 2; i >= 0; --i) {\n          const key = path[i][keyField];\n          if (!visitedNonTailKeys.has(key)) {\n            visitedNonTailKeys.add(key);\n            if (visitedTailKeys.has(key)) {\n              visitedTailKeys.delete(key);\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      const children = n[childrenField];\n      if (children) {\n        visit(children);\n      }\n      path.pop();\n    });\n  }\n  visit(tree);\n  function build(t, sibs) {\n    t.forEach(n => {\n      const key = n[keyField];\n      const isVisitedTail = visitedTailKeys.has(key);\n      const isVisitedNonTail = visitedNonTailKeys.has(key);\n      if (!isVisitedTail && !isVisitedNonTail) return;\n      const children = n[childrenField];\n      if (children) {\n        if (isVisitedTail) {\n          // If it is visited path tail, use origin node\n          sibs.push(n);\n        } else {\n          // It it is not visited path tail, use cloned node\n          expandedKeys.push(key);\n          const clonedNode = Object.assign(Object.assign({}, n), {\n            [childrenField]: []\n          });\n          sibs.push(clonedNode);\n          build(children, clonedNode[childrenField]);\n        }\n      } else {\n        sibs.push(n);\n      }\n    });\n  }\n  build(tree, filteredTree);\n  return {\n    filteredTree,\n    highlightKeySet,\n    expandedKeys\n  };\n}\nexport function treeGetClickTarget(e) {\n  if (happensIn(e, 'checkbox')) {\n    return 'checkbox';\n  } else if (happensIn(e, 'switcher')) {\n    return 'switcher';\n  } else {\n    return 'node';\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}