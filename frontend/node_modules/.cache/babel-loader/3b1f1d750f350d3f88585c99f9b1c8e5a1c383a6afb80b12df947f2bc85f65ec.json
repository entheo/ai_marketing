{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { beforeNextFrameOnce } from 'seemly';\nimport { computed, watch, ref } from 'vue';\nimport { formatLength } from \"../../_utils/index.mjs\";\nimport { getNumberColWidth, getColKey } from \"./utils.mjs\";\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function useScroll(props, {\n  mainTableInstRef,\n  mergedCurrentPageRef,\n  bodyWidthRef\n}) {\n  let lastScrollLeft = 0;\n  const scrollPartRef = ref();\n  const leftActiveFixedColKeyRef = ref(null);\n  const leftActiveFixedChildrenColKeysRef = ref([]);\n  const rightActiveFixedColKeyRef = ref(null);\n  const rightActiveFixedChildrenColKeysRef = ref([]);\n  const styleScrollXRef = computed(() => {\n    return formatLength(props.scrollX);\n  });\n  const leftFixedColumnsRef = computed(() => {\n    return props.columns.filter(column => column.fixed === 'left');\n  });\n  const rightFixedColumnsRef = computed(() => {\n    return props.columns.filter(column => column.fixed === 'right');\n  });\n  const fixedColumnLeftMapRef = computed(() => {\n    const columns = {};\n    let left = 0;\n    function traverse(cols) {\n      cols.forEach(col => {\n        const positionInfo = {\n          start: left,\n          end: 0\n        };\n        columns[getColKey(col)] = positionInfo;\n        if ('children' in col) {\n          traverse(col.children);\n          positionInfo.end = left;\n        } else {\n          left += getNumberColWidth(col) || 0;\n          positionInfo.end = left;\n        }\n      });\n    }\n    traverse(leftFixedColumnsRef.value);\n    return columns;\n  });\n  const fixedColumnRightMapRef = computed(() => {\n    const columns = {};\n    let right = 0;\n    function traverse(cols) {\n      for (let i = cols.length - 1; i >= 0; --i) {\n        const col = cols[i];\n        const positionInfo = {\n          start: right,\n          end: 0\n        };\n        columns[getColKey(col)] = positionInfo;\n        if ('children' in col) {\n          traverse(col.children);\n          positionInfo.end = right;\n        } else {\n          right += getNumberColWidth(col) || 0;\n          positionInfo.end = right;\n        }\n      }\n    }\n    traverse(rightFixedColumnsRef.value);\n    return columns;\n  });\n  function deriveActiveLeftFixedColumn() {\n    var _a, _b;\n    // target is header element\n    const {\n      value: leftFixedColumns\n    } = leftFixedColumnsRef;\n    let leftWidth = 0;\n    const {\n      value: fixedColumnLeftMap\n    } = fixedColumnLeftMapRef;\n    let leftActiveFixedColKey = null;\n    for (let i = 0; i < leftFixedColumns.length; ++i) {\n      const key = getColKey(leftFixedColumns[i]);\n      if (lastScrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {\n        leftActiveFixedColKey = key;\n        leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n      } else {\n        break;\n      }\n    }\n    leftActiveFixedColKeyRef.value = leftActiveFixedColKey;\n  }\n  function deriveActiveLeftFixedChildrenColumns() {\n    leftActiveFixedChildrenColKeysRef.value = [];\n    let activeLeftFixedColumn = props.columns.find(col => getColKey(col) === leftActiveFixedColKeyRef.value);\n    while (activeLeftFixedColumn && 'children' in activeLeftFixedColumn) {\n      const length = activeLeftFixedColumn.children.length;\n      if (length === 0) break;\n      const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];\n      leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));\n      activeLeftFixedColumn = nextActiveLeftFixedColumn;\n    }\n  }\n  function deriveActiveRightFixedColumn() {\n    var _a, _b;\n    // target is header element\n    const {\n      value: rightFixedColumns\n    } = rightFixedColumnsRef;\n    const scrollWidth = Number(props.scrollX);\n    const {\n      value: tableWidth\n    } = bodyWidthRef;\n    if (tableWidth === null) return;\n    let rightWidth = 0;\n    let rightActiveFixedColKey = null;\n    const {\n      value: fixedColumnRightMap\n    } = fixedColumnRightMapRef;\n    for (let i = rightFixedColumns.length - 1; i >= 0; --i) {\n      const key = getColKey(rightFixedColumns[i]);\n      if (Math.round(lastScrollLeft + (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) + tableWidth - rightWidth) < scrollWidth) {\n        rightActiveFixedColKey = key;\n        rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n      } else {\n        break;\n      }\n    }\n    rightActiveFixedColKeyRef.value = rightActiveFixedColKey;\n  }\n  function deriveActiveRightFixedChildrenColumns() {\n    rightActiveFixedChildrenColKeysRef.value = [];\n    let activeRightFixedColumn = props.columns.find(col => getColKey(col) === rightActiveFixedColKeyRef.value);\n    while (activeRightFixedColumn && 'children' in activeRightFixedColumn && activeRightFixedColumn.children.length) {\n      const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];\n      rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));\n      activeRightFixedColumn = nextActiveRightFixedColumn;\n    }\n  }\n  function getScrollElements() {\n    const header = mainTableInstRef.value ? mainTableInstRef.value.getHeaderElement() : null;\n    const body = mainTableInstRef.value ? mainTableInstRef.value.getBodyElement() : null;\n    return {\n      header,\n      body\n    };\n  }\n  function scrollMainTableBodyToTop() {\n    const {\n      body\n    } = getScrollElements();\n    if (body) {\n      body.scrollTop = 0;\n    }\n  }\n  function handleTableHeaderScroll() {\n    if (scrollPartRef.value !== 'body') {\n      beforeNextFrameOnce(syncScrollState);\n    } else {\n      scrollPartRef.value = undefined;\n    }\n  }\n  function handleTableBodyScroll(e) {\n    var _a;\n    (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);\n    if (scrollPartRef.value !== 'head') {\n      beforeNextFrameOnce(syncScrollState);\n    } else {\n      scrollPartRef.value = undefined;\n    }\n  }\n  function syncScrollState() {\n    // We can't simply use props.scrollX to determine whether the table has\n    // need to be sync since user may set column width for each column.\n    // Just let it be, the scroll listener won't be triggered for a basic table.\n    const {\n      header,\n      body\n    } = getScrollElements();\n    if (!body) return;\n    const {\n      value: tableWidth\n    } = bodyWidthRef;\n    if (tableWidth === null) return;\n    if (props.maxHeight || props.flexHeight) {\n      if (!header) return;\n      // we need to deal with overscroll\n      const directionHead = lastScrollLeft - header.scrollLeft;\n      scrollPartRef.value = directionHead !== 0 ? 'head' : 'body';\n      if (scrollPartRef.value === 'head') {\n        lastScrollLeft = header.scrollLeft;\n        body.scrollLeft = lastScrollLeft;\n      } else {\n        lastScrollLeft = body.scrollLeft;\n        header.scrollLeft = lastScrollLeft;\n      }\n    } else {\n      lastScrollLeft = body.scrollLeft;\n    }\n    deriveActiveLeftFixedColumn();\n    deriveActiveLeftFixedChildrenColumns();\n    deriveActiveRightFixedColumn();\n    deriveActiveRightFixedChildrenColumns();\n  }\n  function setHeaderScrollLeft(left) {\n    const {\n      header\n    } = getScrollElements();\n    if (!header) return;\n    header.scrollLeft = left;\n    syncScrollState();\n  }\n  watch(mergedCurrentPageRef, () => {\n    scrollMainTableBodyToTop();\n  });\n  return {\n    styleScrollXRef,\n    fixedColumnLeftMapRef,\n    fixedColumnRightMapRef,\n    leftFixedColumnsRef,\n    rightFixedColumnsRef,\n    leftActiveFixedColKeyRef,\n    leftActiveFixedChildrenColKeysRef,\n    rightActiveFixedColKeyRef,\n    rightActiveFixedChildrenColKeysRef,\n    syncScrollState,\n    handleTableBodyScroll,\n    handleTableHeaderScroll,\n    setHeaderScrollLeft\n  };\n}","map":{"version":3,"names":["beforeNextFrameOnce","computed","watch","ref","formatLength","getNumberColWidth","getColKey","useScroll","props","mainTableInstRef","mergedCurrentPageRef","bodyWidthRef","lastScrollLeft","scrollPartRef","leftActiveFixedColKeyRef","leftActiveFixedChildrenColKeysRef","rightActiveFixedColKeyRef","rightActiveFixedChildrenColKeysRef","styleScrollXRef","scrollX","leftFixedColumnsRef","columns","filter","column","fixed","rightFixedColumnsRef","fixedColumnLeftMapRef","left","traverse","cols","forEach","col","positionInfo","start","end","children","value","fixedColumnRightMapRef","right","i","length","deriveActiveLeftFixedColumn","_a","_b","leftFixedColumns","leftWidth","fixedColumnLeftMap","leftActiveFixedColKey","key","deriveActiveLeftFixedChildrenColumns","activeLeftFixedColumn","find","nextActiveLeftFixedColumn","push","deriveActiveRightFixedColumn","rightFixedColumns","scrollWidth","Number","tableWidth","rightWidth","rightActiveFixedColKey","fixedColumnRightMap","Math","round","deriveActiveRightFixedChildrenColumns","activeRightFixedColumn","nextActiveRightFixedColumn","getScrollElements","header","getHeaderElement","body","getBodyElement","scrollMainTableBodyToTop","scrollTop","handleTableHeaderScroll","syncScrollState","undefined","handleTableBodyScroll","e","onScroll","call","maxHeight","flexHeight","directionHead","scrollLeft","setHeaderScrollLeft"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/naive-ui/es/data-table/src/use-scroll.mjs"],"sourcesContent":["import { beforeNextFrameOnce } from 'seemly';\nimport { computed, watch, ref } from 'vue';\nimport { formatLength } from \"../../_utils/index.mjs\";\nimport { getNumberColWidth, getColKey } from \"./utils.mjs\";\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function useScroll(props, {\n  mainTableInstRef,\n  mergedCurrentPageRef,\n  bodyWidthRef\n}) {\n  let lastScrollLeft = 0;\n  const scrollPartRef = ref();\n  const leftActiveFixedColKeyRef = ref(null);\n  const leftActiveFixedChildrenColKeysRef = ref([]);\n  const rightActiveFixedColKeyRef = ref(null);\n  const rightActiveFixedChildrenColKeysRef = ref([]);\n  const styleScrollXRef = computed(() => {\n    return formatLength(props.scrollX);\n  });\n  const leftFixedColumnsRef = computed(() => {\n    return props.columns.filter(column => column.fixed === 'left');\n  });\n  const rightFixedColumnsRef = computed(() => {\n    return props.columns.filter(column => column.fixed === 'right');\n  });\n  const fixedColumnLeftMapRef = computed(() => {\n    const columns = {};\n    let left = 0;\n    function traverse(cols) {\n      cols.forEach(col => {\n        const positionInfo = {\n          start: left,\n          end: 0\n        };\n        columns[getColKey(col)] = positionInfo;\n        if ('children' in col) {\n          traverse(col.children);\n          positionInfo.end = left;\n        } else {\n          left += getNumberColWidth(col) || 0;\n          positionInfo.end = left;\n        }\n      });\n    }\n    traverse(leftFixedColumnsRef.value);\n    return columns;\n  });\n  const fixedColumnRightMapRef = computed(() => {\n    const columns = {};\n    let right = 0;\n    function traverse(cols) {\n      for (let i = cols.length - 1; i >= 0; --i) {\n        const col = cols[i];\n        const positionInfo = {\n          start: right,\n          end: 0\n        };\n        columns[getColKey(col)] = positionInfo;\n        if ('children' in col) {\n          traverse(col.children);\n          positionInfo.end = right;\n        } else {\n          right += getNumberColWidth(col) || 0;\n          positionInfo.end = right;\n        }\n      }\n    }\n    traverse(rightFixedColumnsRef.value);\n    return columns;\n  });\n  function deriveActiveLeftFixedColumn() {\n    var _a, _b;\n    // target is header element\n    const {\n      value: leftFixedColumns\n    } = leftFixedColumnsRef;\n    let leftWidth = 0;\n    const {\n      value: fixedColumnLeftMap\n    } = fixedColumnLeftMapRef;\n    let leftActiveFixedColKey = null;\n    for (let i = 0; i < leftFixedColumns.length; ++i) {\n      const key = getColKey(leftFixedColumns[i]);\n      if (lastScrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {\n        leftActiveFixedColKey = key;\n        leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n      } else {\n        break;\n      }\n    }\n    leftActiveFixedColKeyRef.value = leftActiveFixedColKey;\n  }\n  function deriveActiveLeftFixedChildrenColumns() {\n    leftActiveFixedChildrenColKeysRef.value = [];\n    let activeLeftFixedColumn = props.columns.find(col => getColKey(col) === leftActiveFixedColKeyRef.value);\n    while (activeLeftFixedColumn && 'children' in activeLeftFixedColumn) {\n      const length = activeLeftFixedColumn.children.length;\n      if (length === 0) break;\n      const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];\n      leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));\n      activeLeftFixedColumn = nextActiveLeftFixedColumn;\n    }\n  }\n  function deriveActiveRightFixedColumn() {\n    var _a, _b;\n    // target is header element\n    const {\n      value: rightFixedColumns\n    } = rightFixedColumnsRef;\n    const scrollWidth = Number(props.scrollX);\n    const {\n      value: tableWidth\n    } = bodyWidthRef;\n    if (tableWidth === null) return;\n    let rightWidth = 0;\n    let rightActiveFixedColKey = null;\n    const {\n      value: fixedColumnRightMap\n    } = fixedColumnRightMapRef;\n    for (let i = rightFixedColumns.length - 1; i >= 0; --i) {\n      const key = getColKey(rightFixedColumns[i]);\n      if (Math.round(lastScrollLeft + (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) + tableWidth - rightWidth) < scrollWidth) {\n        rightActiveFixedColKey = key;\n        rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n      } else {\n        break;\n      }\n    }\n    rightActiveFixedColKeyRef.value = rightActiveFixedColKey;\n  }\n  function deriveActiveRightFixedChildrenColumns() {\n    rightActiveFixedChildrenColKeysRef.value = [];\n    let activeRightFixedColumn = props.columns.find(col => getColKey(col) === rightActiveFixedColKeyRef.value);\n    while (activeRightFixedColumn && 'children' in activeRightFixedColumn && activeRightFixedColumn.children.length) {\n      const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];\n      rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));\n      activeRightFixedColumn = nextActiveRightFixedColumn;\n    }\n  }\n  function getScrollElements() {\n    const header = mainTableInstRef.value ? mainTableInstRef.value.getHeaderElement() : null;\n    const body = mainTableInstRef.value ? mainTableInstRef.value.getBodyElement() : null;\n    return {\n      header,\n      body\n    };\n  }\n  function scrollMainTableBodyToTop() {\n    const {\n      body\n    } = getScrollElements();\n    if (body) {\n      body.scrollTop = 0;\n    }\n  }\n  function handleTableHeaderScroll() {\n    if (scrollPartRef.value !== 'body') {\n      beforeNextFrameOnce(syncScrollState);\n    } else {\n      scrollPartRef.value = undefined;\n    }\n  }\n  function handleTableBodyScroll(e) {\n    var _a;\n    (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);\n    if (scrollPartRef.value !== 'head') {\n      beforeNextFrameOnce(syncScrollState);\n    } else {\n      scrollPartRef.value = undefined;\n    }\n  }\n  function syncScrollState() {\n    // We can't simply use props.scrollX to determine whether the table has\n    // need to be sync since user may set column width for each column.\n    // Just let it be, the scroll listener won't be triggered for a basic table.\n    const {\n      header,\n      body\n    } = getScrollElements();\n    if (!body) return;\n    const {\n      value: tableWidth\n    } = bodyWidthRef;\n    if (tableWidth === null) return;\n    if (props.maxHeight || props.flexHeight) {\n      if (!header) return;\n      // we need to deal with overscroll\n      const directionHead = lastScrollLeft - header.scrollLeft;\n      scrollPartRef.value = directionHead !== 0 ? 'head' : 'body';\n      if (scrollPartRef.value === 'head') {\n        lastScrollLeft = header.scrollLeft;\n        body.scrollLeft = lastScrollLeft;\n      } else {\n        lastScrollLeft = body.scrollLeft;\n        header.scrollLeft = lastScrollLeft;\n      }\n    } else {\n      lastScrollLeft = body.scrollLeft;\n    }\n    deriveActiveLeftFixedColumn();\n    deriveActiveLeftFixedChildrenColumns();\n    deriveActiveRightFixedColumn();\n    deriveActiveRightFixedChildrenColumns();\n  }\n  function setHeaderScrollLeft(left) {\n    const {\n      header\n    } = getScrollElements();\n    if (!header) return;\n    header.scrollLeft = left;\n    syncScrollState();\n  }\n  watch(mergedCurrentPageRef, () => {\n    scrollMainTableBodyToTop();\n  });\n  return {\n    styleScrollXRef,\n    fixedColumnLeftMapRef,\n    fixedColumnRightMapRef,\n    leftFixedColumnsRef,\n    rightFixedColumnsRef,\n    leftActiveFixedColKeyRef,\n    leftActiveFixedChildrenColKeysRef,\n    rightActiveFixedColKeyRef,\n    rightActiveFixedChildrenColKeysRef,\n    syncScrollState,\n    handleTableBodyScroll,\n    handleTableHeaderScroll,\n    setHeaderScrollLeft\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}