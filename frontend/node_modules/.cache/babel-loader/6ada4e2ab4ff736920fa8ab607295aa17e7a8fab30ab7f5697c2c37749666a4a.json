{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect, inject } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { depx, getPadding, pxfy } from 'seemly';\nimport { treeSelectInjectionKey } from \"../../tree-select/src/interface.mjs\";\nimport { useConfig, useTheme, useThemeClass, useRtl } from \"../../_mixins/index.mjs\";\nimport { call, createDataKey, resolveSlot, warn, warnOnce } from \"../../_utils/index.mjs\";\nimport { NxScrollbar } from \"../../_internal/index.mjs\";\nimport { treeLight } from \"../styles/index.mjs\";\nimport { NEmpty } from \"../../empty/index.mjs\";\nimport NTreeNode from \"./TreeNode.mjs\";\nimport { keysWithFilter, emptyImage, filterTree, isNodeDisabled, useMergedCheckStrategy } from \"./utils.mjs\";\nimport { useKeyboard } from \"./keyboard.mjs\";\nimport { treeInjectionKey } from \"./interface.mjs\";\nimport MotionWrapper from \"./MotionWrapper.mjs\";\nimport { defaultAllowDrop } from \"./dnd.mjs\";\nimport style from \"./styles/index.cssr.mjs\";\nexport function createTreeMateOptions(keyField, childrenField, disabledField, getChildren) {\n  const settledGetChildren = getChildren || (node => {\n    return node[childrenField];\n  });\n  return {\n    getIsGroup() {\n      return false;\n    },\n    getKey(node) {\n      return node[keyField];\n    },\n    getChildren: settledGetChildren,\n    getDisabled(node) {\n      return !!(node[disabledField] || node.checkboxDisabled);\n    }\n  };\n}\nexport const treeSharedProps = {\n  allowCheckingNotLoaded: Boolean,\n  filter: Function,\n  defaultExpandAll: Boolean,\n  expandedKeys: Array,\n  keyField: {\n    type: String,\n    default: 'key'\n  },\n  labelField: {\n    type: String,\n    default: 'label'\n  },\n  childrenField: {\n    type: String,\n    default: 'children'\n  },\n  disabledField: {\n    type: String,\n    default: 'disabled'\n  },\n  defaultExpandedKeys: {\n    type: Array,\n    default: () => []\n  },\n  indeterminateKeys: Array,\n  renderSwitcherIcon: Function,\n  onUpdateIndeterminateKeys: [Function, Array],\n  'onUpdate:indeterminateKeys': [Function, Array],\n  onUpdateExpandedKeys: [Function, Array],\n  'onUpdate:expandedKeys': [Function, Array],\n  overrideDefaultNodeClickBehavior: Function\n};\nexport const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {\n  accordion: Boolean,\n  showIrrelevantNodes: {\n    type: Boolean,\n    default: true\n  },\n  data: {\n    type: Array,\n    default: () => []\n  },\n  expandOnDragenter: {\n    type: Boolean,\n    default: true\n  },\n  expandOnClick: Boolean,\n  checkOnClick: {\n    type: [Boolean, Function],\n    default: false\n  },\n  cancelable: {\n    type: Boolean,\n    default: true\n  },\n  checkable: Boolean,\n  draggable: Boolean,\n  blockNode: Boolean,\n  blockLine: Boolean,\n  showLine: Boolean,\n  disabled: Boolean,\n  checkedKeys: Array,\n  defaultCheckedKeys: {\n    type: Array,\n    default: () => []\n  },\n  selectedKeys: Array,\n  defaultSelectedKeys: {\n    type: Array,\n    default: () => []\n  },\n  multiple: Boolean,\n  pattern: {\n    type: String,\n    default: ''\n  },\n  onLoad: Function,\n  cascade: Boolean,\n  selectable: {\n    type: Boolean,\n    default: true\n  },\n  scrollbarProps: Object,\n  indent: {\n    type: Number,\n    default: 24\n  },\n  allowDrop: {\n    type: Function,\n    default: defaultAllowDrop\n  },\n  animated: {\n    type: Boolean,\n    default: true\n  },\n  checkboxPlacement: {\n    type: String,\n    default: 'left'\n  },\n  virtualScroll: Boolean,\n  watchProps: Array,\n  renderLabel: Function,\n  renderPrefix: Function,\n  renderSuffix: Function,\n  nodeProps: Function,\n  keyboard: {\n    type: Boolean,\n    default: true\n  },\n  getChildren: Function,\n  onDragenter: [Function, Array],\n  onDragleave: [Function, Array],\n  onDragend: [Function, Array],\n  onDragstart: [Function, Array],\n  onDragover: [Function, Array],\n  onDrop: [Function, Array],\n  onUpdateCheckedKeys: [Function, Array],\n  'onUpdate:checkedKeys': [Function, Array],\n  onUpdateSelectedKeys: [Function, Array],\n  'onUpdate:selectedKeys': [Function, Array]\n}), treeSharedProps), {\n  // internal props for tree-select\n  internalTreeSelect: Boolean,\n  internalScrollable: Boolean,\n  internalScrollablePadding: String,\n  // use it to display\n  internalRenderEmpty: Function,\n  internalHighlightKeySet: Object,\n  internalUnifySelectCheck: Boolean,\n  internalCheckboxFocusable: {\n    type: Boolean,\n    default: true\n  },\n  internalFocusable: {\n    // Make tree-select take over keyboard operations\n    type: Boolean,\n    default: true\n  },\n  checkStrategy: {\n    type: String,\n    default: 'all'\n  },\n  /**\n   * @deprecated\n   */\n  leafOnly: Boolean\n});\nexport default defineComponent({\n  name: 'Tree',\n  props: treeProps,\n  setup(props) {\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.leafOnly) {\n          warnOnce('tree', '`leaf-only` is deprecated, please use `check-strategy=\"child\"` instead');\n        }\n      });\n    }\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled,\n      mergedRtlRef\n    } = useConfig(props);\n    const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);\n    const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n    const selfElRef = ref(null);\n    const scrollbarInstRef = ref(null);\n    const virtualListInstRef = ref(null);\n    function getScrollContainer() {\n      var _a;\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n    }\n    function getScrollContent() {\n      var _a;\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n    }\n    const mergedFilterRef = computed(() => {\n      const {\n        filter\n      } = props;\n      if (filter) return filter;\n      const {\n        labelField\n      } = props;\n      return (pattern, node) => {\n        if (!pattern.length) return true;\n        const label = node[labelField];\n        if (typeof label === 'string') {\n          return label.toLowerCase().includes(pattern.toLowerCase());\n        }\n        return false;\n      };\n    });\n    const filteredTreeInfoRef = computed(() => {\n      const {\n        pattern\n      } = props;\n      if (!pattern) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n      if (!pattern.length || !mergedFilterRef.value) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n      return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);\n    });\n    // We don't expect data source to change so we just determine it once\n    const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes ? props.data : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, props.getChildren)));\n    const treeSelectInjection = inject(treeSelectInjectionKey, null);\n    const dataTreeMateRef = props.internalTreeSelect ? treeSelectInjection.dataTreeMate : displayTreeMateRef;\n    const {\n      watchProps\n    } = props;\n    const uncontrolledCheckedKeysRef = ref([]);\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n      watchEffect(() => {\n        uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n      });\n    } else {\n      uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n    }\n    const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n    const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n    const checkedStatusRef = computed(() => {\n      const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      return value;\n    });\n    const mergedCheckStrategyRef = useMergedCheckStrategy(props);\n    const displayedCheckedKeysRef = computed(() => {\n      return checkedStatusRef.value.checkedKeys;\n    });\n    const displayedIndeterminateKeysRef = computed(() => {\n      const {\n        indeterminateKeys\n      } = props;\n      if (indeterminateKeys !== undefined) return indeterminateKeys;\n      return checkedStatusRef.value.indeterminateKeys;\n    });\n    const uncontrolledSelectedKeysRef = ref([]);\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n      watchEffect(() => {\n        uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n      });\n    } else {\n      uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n    }\n    const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n    const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n    const uncontrolledExpandedKeysRef = ref([]);\n    const initUncontrolledExpandedKeys = keys => {\n      uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys === undefined ? props.defaultExpandedKeys : keys;\n    };\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n      // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n      watchEffect(() => {\n        initUncontrolledExpandedKeys(undefined);\n      });\n    } else {\n      // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n      watchEffect(() => {\n        initUncontrolledExpandedKeys(props.defaultExpandedKeys);\n      });\n    }\n    const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n    const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n    const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n    const {\n      pendingNodeKeyRef,\n      handleKeydown\n    } = useKeyboard({\n      props,\n      mergedCheckedKeysRef,\n      mergedSelectedKeysRef,\n      fNodesRef,\n      mergedExpandedKeysRef,\n      handleCheck,\n      handleSelect,\n      handleSwitcherClick\n    });\n    let expandTimerId = null;\n    let nodeKeyToBeExpanded = null;\n    const uncontrolledHighlightKeySetRef = ref(new Set());\n    const controlledHighlightKeySetRef = computed(() => {\n      return props.internalHighlightKeySet || filteredTreeInfoRef.value.highlightKeySet;\n    });\n    const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n    const loadingKeysRef = ref(new Set());\n    const expandedNonLoadingKeysRef = computed(() => {\n      return mergedExpandedKeysRef.value.filter(key => !loadingKeysRef.value.has(key));\n    });\n    let dragStartX = 0;\n    const draggingNodeRef = ref(null);\n    const droppingNodeRef = ref(null);\n    const droppingMouseNodeRef = ref(null);\n    const droppingPositionRef = ref(null);\n    const droppingOffsetLevelRef = ref(0);\n    const droppingNodeParentRef = computed(() => {\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      if (!droppingNode) return null;\n      // May avoid overlap between line mark of first child & rect mark of parent\n      // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n      //   return null\n      // }\n      return droppingNode.parent;\n    });\n    // shallow watch data\n    let isDataReset = false;\n    watch(toRef(props, 'data'), () => {\n      isDataReset = true;\n      void nextTick(() => {\n        isDataReset = false;\n      });\n      loadingKeysRef.value.clear();\n      pendingNodeKeyRef.value = null;\n      resetDndState();\n    }, {\n      deep: false\n    });\n    let expandAnimationDisabled = false;\n    const disableExpandAnimationForOneTick = () => {\n      expandAnimationDisabled = true;\n      void nextTick(() => {\n        expandAnimationDisabled = false;\n      });\n    };\n    let memoizedExpandedKeys;\n    watch(toRef(props, 'pattern'), (value, oldValue) => {\n      if (props.showIrrelevantNodes) {\n        memoizedExpandedKeys = undefined;\n        if (value) {\n          const {\n            expandedKeys: expandedKeysAfterChange,\n            highlightKeySet\n          } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n          uncontrolledHighlightKeySetRef.value = highlightKeySet;\n          disableExpandAnimationForOneTick();\n          doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {\n            node: null,\n            action: 'filter'\n          });\n        } else {\n          uncontrolledHighlightKeySetRef.value = new Set();\n        }\n      } else {\n        if (!value.length) {\n          if (memoizedExpandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys), {\n              node: null,\n              action: 'filter'\n            });\n          }\n        } else {\n          if (!oldValue.length) {\n            memoizedExpandedKeys = mergedExpandedKeysRef.value;\n          }\n          const {\n            expandedKeys\n          } = filteredTreeInfoRef.value;\n          if (expandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys), {\n              node: null,\n              action: 'filter'\n            });\n          }\n        }\n      }\n    });\n    function triggerLoading(node) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          onLoad\n        } = props;\n        if (!onLoad) {\n          if (process.env.NODE_ENV !== 'production') {\n            warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n          }\n          yield Promise.resolve();\n          return;\n        }\n        const {\n          value: loadingKeys\n        } = loadingKeysRef;\n        if (!loadingKeys.has(node.key)) {\n          loadingKeys.add(node.key);\n          try {\n            const loadResult = yield onLoad(node.rawNode);\n            if (loadResult === false) {\n              resetDragExpandState();\n            }\n          } catch (loadError) {\n            console.error(loadError);\n            resetDragExpandState();\n          }\n          loadingKeys.delete(node.key);\n        }\n      });\n    }\n    watchEffect(() => {\n      var _a;\n      const {\n        value: displayTreeMate\n      } = displayTreeMateRef;\n      if (!displayTreeMate) return;\n      const {\n        getNode\n      } = displayTreeMate;\n      (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach(key => {\n        const node = getNode(key);\n        if (node && !node.shallowLoaded) {\n          void triggerLoading(node);\n        }\n      });\n    });\n    // animation in progress\n    const aipRef = ref(false);\n    // animation flattened nodes\n    const afNodesRef = ref([]);\n    // Note: Since the virtual list depends on min height, if there's a node\n    // whose height starts from 0, the virtual list will have a wrong height\n    // during animation. This will seldom cause wired scrollbar status. It is\n    // fixable and need some changes in vueuc, I've no time so I just leave it\n    // here. Maybe the bug won't be fixed during the life time of the project.\n    watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n      if (!props.animated || expandAnimationDisabled) {\n        void nextTick(syncScrollbar);\n        return;\n      }\n      if (isDataReset) {\n        return;\n      }\n      const nodeHeight = depx(themeRef.value.self.nodeHeight);\n      const prevVSet = new Set(prevValue);\n      let addedKey = null;\n      let removedKey = null;\n      for (const expandedKey of value) {\n        if (!prevVSet.has(expandedKey)) {\n          if (addedKey !== null) return; // multi expand, not triggered by click\n          addedKey = expandedKey;\n        }\n      }\n      const currentVSet = new Set(value);\n      for (const expandedKey of prevValue) {\n        if (!currentVSet.has(expandedKey)) {\n          if (removedKey !== null) return; // multi collapse, not triggered by click\n          removedKey = expandedKey;\n        }\n      }\n      if (addedKey === null && removedKey === null) {\n        // 1. multi action, not triggered by click\n        // 2. no action, don't know what happened\n        return;\n      }\n      const {\n        virtualScroll\n      } = props;\n      const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n      const viewportItemCount = Math.ceil(viewportHeight / nodeHeight) + 1;\n      // play add animation\n      let baseExpandedKeys;\n      if (addedKey !== null) {\n        baseExpandedKeys = prevValue;\n      }\n      if (removedKey !== null) {\n        if (baseExpandedKeys === undefined) {\n          baseExpandedKeys = value;\n        } else {\n          baseExpandedKeys = baseExpandedKeys.filter(key => key !== removedKey);\n        }\n      }\n      aipRef.value = true;\n      afNodesRef.value = displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);\n      if (addedKey !== null) {\n        const expandedNodeIndex = afNodesRef.value.findIndex(node => node.key === addedKey);\n        if (~expandedNodeIndex) {\n          const children =\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          afNodesRef.value[expandedNodeIndex].children;\n          // sometimes user will pass leaf keys in\n          if (children) {\n            const expandedChildren = flatten(children, value);\n            afNodesRef.value.splice(expandedNodeIndex + 1, 0, {\n              __motion: true,\n              mode: 'expand',\n              height: virtualScroll ? expandedChildren.length * nodeHeight : undefined,\n              nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren\n            });\n          }\n        }\n      }\n      if (removedKey !== null) {\n        const collapsedNodeIndex = afNodesRef.value.findIndex(node => node.key === removedKey);\n        if (~collapsedNodeIndex) {\n          const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;\n          // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n          // but maybe children removed\n          if (!collapsedNodeChildren) return;\n          // play remove animation\n          aipRef.value = true;\n          const collapsedChildren = flatten(collapsedNodeChildren, value);\n          afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {\n            __motion: true,\n            mode: 'collapse',\n            height: virtualScroll ? collapsedChildren.length * nodeHeight : undefined,\n            nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren\n          });\n        }\n      }\n    });\n    const getFIndexRef = computed(() => {\n      return createIndexGetter(fNodesRef.value);\n    });\n    const mergedFNodesRef = computed(() => {\n      if (aipRef.value) return afNodesRef.value;else return fNodesRef.value;\n    });\n    function syncScrollbar() {\n      const {\n        value: scrollbarInst\n      } = scrollbarInstRef;\n      if (scrollbarInst) scrollbarInst.sync();\n    }\n    function handleAfterEnter() {\n      aipRef.value = false;\n      if (props.virtualScroll) {\n        // If virtual scroll, we won't listen to resize during animation, so\n        // resize callback of virtual list won't be called and as a result\n        // scrollbar won't sync. We need to sync scrollbar manually.\n        void nextTick(syncScrollbar);\n      }\n    }\n    function getOptionsByKeys(keys) {\n      const {\n        getNode\n      } = dataTreeMateRef.value;\n      return keys.map(key => {\n        var _a;\n        return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;\n      });\n    }\n    function doUpdateExpandedKeys(value, option, meta) {\n      const {\n        'onUpdate:expandedKeys': _onUpdateExpandedKeys,\n        onUpdateExpandedKeys\n      } = props;\n      uncontrolledExpandedKeysRef.value = value;\n      if (_onUpdateExpandedKeys) {\n        call(_onUpdateExpandedKeys, value, option, meta);\n      }\n      if (onUpdateExpandedKeys) {\n        call(onUpdateExpandedKeys, value, option, meta);\n      }\n    }\n    function doUpdateCheckedKeys(value, option, meta) {\n      const {\n        'onUpdate:checkedKeys': _onUpdateCheckedKeys,\n        onUpdateCheckedKeys\n      } = props;\n      uncontrolledCheckedKeysRef.value = value;\n      if (onUpdateCheckedKeys) {\n        call(onUpdateCheckedKeys, value, option, meta);\n      }\n      if (_onUpdateCheckedKeys) {\n        call(_onUpdateCheckedKeys, value, option, meta);\n      }\n    }\n    function doUpdateIndeterminateKeys(value, option) {\n      const {\n        'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys,\n        onUpdateIndeterminateKeys\n      } = props;\n      if (_onUpdateIndeterminateKeys) {\n        call(_onUpdateIndeterminateKeys, value, option);\n      }\n      if (onUpdateIndeterminateKeys) {\n        call(onUpdateIndeterminateKeys, value, option);\n      }\n    }\n    function doUpdateSelectedKeys(value, option, meta) {\n      const {\n        'onUpdate:selectedKeys': _onUpdateSelectedKeys,\n        onUpdateSelectedKeys\n      } = props;\n      uncontrolledSelectedKeysRef.value = value;\n      if (onUpdateSelectedKeys) {\n        call(onUpdateSelectedKeys, value, option, meta);\n      }\n      if (_onUpdateSelectedKeys) {\n        call(_onUpdateSelectedKeys, value, option, meta);\n      }\n    }\n    // Drag & Drop\n    function doDragEnter(info) {\n      const {\n        onDragenter\n      } = props;\n      if (onDragenter) call(onDragenter, info);\n    }\n    function doDragLeave(info) {\n      const {\n        onDragleave\n      } = props;\n      if (onDragleave) call(onDragleave, info);\n    }\n    function doDragEnd(info) {\n      const {\n        onDragend\n      } = props;\n      if (onDragend) call(onDragend, info);\n    }\n    function doDragStart(info) {\n      const {\n        onDragstart\n      } = props;\n      if (onDragstart) call(onDragstart, info);\n    }\n    function doDragOver(info) {\n      const {\n        onDragover\n      } = props;\n      if (onDragover) call(onDragover, info);\n    }\n    function doDrop(info) {\n      const {\n        onDrop\n      } = props;\n      if (onDrop) call(onDrop, info);\n    }\n    function resetDndState() {\n      resetDragState();\n      resetDropState();\n    }\n    function resetDragState() {\n      draggingNodeRef.value = null;\n    }\n    function resetDropState() {\n      droppingOffsetLevelRef.value = 0;\n      droppingNodeRef.value = null;\n      droppingMouseNodeRef.value = null;\n      droppingPositionRef.value = null;\n      resetDragExpandState();\n    }\n    function resetDragExpandState() {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n      nodeKeyToBeExpanded = null;\n    }\n    function handleCheck(node, checked) {\n      // We don't guard for leaf only since we have done it in view layer\n      if (props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      if (props.internalUnifySelectCheck && !props.multiple) {\n        handleSelect(node);\n        return;\n      }\n      const checkedAction = checked ? 'check' : 'uncheck';\n      const {\n        checkedKeys,\n        indeterminateKeys\n      } = dataTreeMateRef.value[checkedAction](node.key, displayedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        checkStrategy: mergedCheckStrategyRef.value,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys), {\n        node: node.rawNode,\n        action: checkedAction\n      });\n      doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n    }\n    function toggleExpand(node) {\n      if (props.disabled) return;\n      const {\n        key\n      } = node;\n      const {\n        value: mergedExpandedKeys\n      } = mergedExpandedKeysRef;\n      const index = mergedExpandedKeys.findIndex(expandNodeId => expandNodeId === key);\n      if (~index) {\n        const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n        expandedKeysAfterChange.splice(index, 1);\n        doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {\n          node: node.rawNode,\n          action: 'collapse'\n        });\n      } else {\n        const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n        if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n          return;\n        }\n        let nextKeys;\n        if (props.accordion) {\n          const siblingKeySet = new Set(node.siblings.map(({\n            key\n          }) => key));\n          nextKeys = mergedExpandedKeys.filter(expandedKey => {\n            return !siblingKeySet.has(expandedKey);\n          });\n          nextKeys.push(key);\n        } else {\n          nextKeys = mergedExpandedKeys.concat(key);\n        }\n        doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {\n          node: node.rawNode,\n          action: 'expand'\n        });\n      }\n    }\n    function handleSwitcherClick(node) {\n      if (props.disabled || aipRef.value) return;\n      toggleExpand(node);\n    }\n    function handleSelect(node) {\n      if (props.disabled || !props.selectable) {\n        return;\n      }\n      pendingNodeKeyRef.value = node.key;\n      if (props.internalUnifySelectCheck) {\n        const {\n          value: {\n            checkedKeys,\n            indeterminateKeys\n          }\n        } = checkedStatusRef;\n        if (props.multiple) {\n          handleCheck(node, !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key)));\n        } else {\n          doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]), {\n            node: node.rawNode,\n            action: 'check'\n          });\n        }\n      }\n      if (props.multiple) {\n        const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n        const index = selectedKeys.findIndex(key => key === node.key);\n        if (~index) {\n          if (props.cancelable) {\n            selectedKeys.splice(index, 1);\n          }\n        } else if (!~index) {\n          selectedKeys.push(node.key);\n        }\n        doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys), {\n          node: node.rawNode,\n          action: ~index ? 'unselect' : 'select'\n        });\n      } else {\n        const selectedKeys = mergedSelectedKeysRef.value;\n        if (selectedKeys.includes(node.key)) {\n          if (props.cancelable) {\n            doUpdateSelectedKeys([], [], {\n              node: node.rawNode,\n              action: 'unselect'\n            });\n          }\n        } else {\n          doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]), {\n            node: node.rawNode,\n            action: 'select'\n          });\n        }\n      }\n    }\n    function expandDragEnterNode(node) {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n      // Don't expand leaf node.\n      if (node.isLeaf) return;\n      nodeKeyToBeExpanded = node.key;\n      const expand = () => {\n        if (nodeKeyToBeExpanded !== node.key) return;\n        const {\n          value: droppingMouseNode\n        } = droppingMouseNodeRef;\n        if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {\n          const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n          doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {\n            node: node.rawNode,\n            action: 'expand'\n          });\n        }\n        expandTimerId = null;\n        nodeKeyToBeExpanded = null;\n      };\n      if (!node.shallowLoaded) {\n        expandTimerId = window.setTimeout(() => {\n          void triggerLoading(node).then(() => {\n            expand();\n          });\n        }, 1000);\n      } else {\n        expandTimerId = window.setTimeout(() => {\n          expand();\n        }, 1000);\n      }\n    }\n    // Dnd\n    function handleDragEnter({\n      event,\n      node\n    }) {\n      // node should be a tmNode\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      handleDragOver({\n        event,\n        node\n      }, false);\n      doDragEnter({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragLeave({\n      event,\n      node\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      doDragLeave({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragLeaveTree(e) {\n      if (e.target !== e.currentTarget) return;\n      resetDropState();\n    }\n    // Dragend is ok, we don't need to add global listener to reset drag status\n    function handleDragEnd({\n      event,\n      node\n    }) {\n      resetDndState();\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      doDragEnd({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragStart({\n      event,\n      node\n    }) {\n      var _a;\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      // Most of time, the image will block user's view\n      emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n      dragStartX = event.clientX;\n      draggingNodeRef.value = node;\n      doDragStart({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragOver({\n      event,\n      node\n    }, emit = true) {\n      var _a;\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      if (!draggingNode) return;\n      const {\n        allowDrop,\n        indent\n      } = props;\n      if (emit) doDragOver({\n        event,\n        node: node.rawNode\n      });\n      // Update dropping node\n      const el = event.currentTarget;\n      const {\n        height: elOffsetHeight,\n        top: elClientTop\n      } = el.getBoundingClientRect();\n      const eventOffsetY = event.clientY - elClientTop;\n      let mousePosition;\n      const allowDropInside = allowDrop({\n        node: node.rawNode,\n        dropPosition: 'inside',\n        phase: 'drag'\n      });\n      if (allowDropInside) {\n        if (eventOffsetY <= 8) {\n          mousePosition = 'before';\n        } else if (eventOffsetY >= elOffsetHeight - 8) {\n          mousePosition = 'after';\n        } else {\n          mousePosition = 'inside';\n        }\n      } else {\n        if (eventOffsetY <= elOffsetHeight / 2) {\n          mousePosition = 'before';\n        } else {\n          mousePosition = 'after';\n        }\n      }\n      const {\n        value: getFindex\n      } = getFIndexRef;\n      /** determine the drop position and drop node */\n      /** the dropping node needn't to be the mouse hovering node! */\n      /**\n       * if there is something i've learned from implementing a complex\n       * drag & drop. that is never write unit test before you really figure\n       * out what behavior is exactly you want.\n       */\n      let finalDropNode;\n      let finalDropPosition;\n      const hoverNodeFIndex = getFindex(node.key);\n      if (hoverNodeFIndex === null) {\n        resetDropState();\n        return;\n      }\n      let mouseAtExpandedNonLeafNode = false;\n      if (mousePosition === 'inside') {\n        finalDropNode = node;\n        finalDropPosition = 'inside';\n      } else {\n        if (mousePosition === 'before') {\n          if (node.isFirstChild) {\n            finalDropNode = node;\n            finalDropPosition = 'before';\n          } else {\n            finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n            finalDropPosition = 'after';\n          }\n        } else {\n          finalDropNode = node;\n          finalDropPosition = 'after';\n        }\n      }\n      // If the node is non-leaf and it is expanded, we don't allow it to\n      // drop after it and change it to drop before its next view sibling\n      if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n        mouseAtExpandedNonLeafNode = true;\n        if (finalDropPosition === 'after') {\n          finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n          if (!finalDropNode) {\n            // maybe there is no next view sibling when non-leaf node has no\n            // children and it is the last node in the tree\n            finalDropNode = node;\n            finalDropPosition = 'inside';\n          } else {\n            finalDropPosition = 'before';\n          }\n        }\n      }\n      const droppingMouseNode = finalDropNode;\n      droppingMouseNodeRef.value = droppingMouseNode;\n      // This is a speacial case, user is dragging a last child itself, so we\n      // only view it as they are trying to drop after it.\n      // There are some relevant codes in bailout 1's child branch.\n      // Also, the expand bailout should have a high priority. If it's non-leaf\n      // node and expanded, keep its origin drop position\n      if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {\n        finalDropPosition = 'after';\n      }\n      if (finalDropPosition === 'after') {\n        let offset = dragStartX - event.clientX; // drag left => > 0\n        let offsetLevel = 0;\n        while (offset >= indent / 2 &&\n        // divide by 2 to make it easier to trigger\n        finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {\n          offset -= indent;\n          offsetLevel += 1;\n          finalDropNode = finalDropNode.parent;\n        }\n        droppingOffsetLevelRef.value = offsetLevel;\n      } else {\n        droppingOffsetLevelRef.value = 0;\n      }\n      // Bailout 1\n      // Drag self into self\n      // Drag it into direct parent\n      if (draggingNode.contains(finalDropNode) || finalDropPosition === 'inside' && ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key) {\n        if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key) {\n          // This is special case that we want ui to show a mark to guide user\n          // to start dragging. Nor they will think nothing happens.\n          // However this is an invalid drop, we need to guard it inside\n          // handleDrop\n        } else {\n          resetDropState();\n          return;\n        }\n      }\n      // Bailout 3\n      if (!allowDrop({\n        node: finalDropNode.rawNode,\n        dropPosition: finalDropPosition,\n        phase: 'drag'\n      })) {\n        resetDropState();\n        return;\n      }\n      if (draggingNode.key === finalDropNode.key) {\n        // don't expand when drag on itself\n        resetDragExpandState();\n      } else {\n        if (nodeKeyToBeExpanded !== finalDropNode.key) {\n          if (finalDropPosition === 'inside') {\n            if (props.expandOnDragenter) {\n              expandDragEnterNode(finalDropNode);\n              // Bailout 4\n              // not try to loading\n              if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {\n                resetDndState();\n                return;\n              }\n            } else {\n              // Bailout 5\n              // never expands on drag\n              if (!finalDropNode.shallowLoaded) {\n                resetDndState();\n                return;\n              }\n            }\n          } else {\n            resetDragExpandState();\n          }\n        } else {\n          if (finalDropPosition !== 'inside') {\n            resetDragExpandState();\n          }\n        }\n      }\n      droppingPositionRef.value = finalDropPosition;\n      droppingNodeRef.value = finalDropNode;\n    }\n    function handleDrop({\n      event,\n      node,\n      dropPosition\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      const {\n        value: droppingPosition\n      } = droppingPositionRef;\n      if (!draggingNode || !droppingNode || !droppingPosition) {\n        return;\n      }\n      // Bailout 1\n      if (!props.allowDrop({\n        node: droppingNode.rawNode,\n        dropPosition: droppingPosition,\n        phase: 'drag'\n      })) {\n        return;\n      }\n      // Bailout 2\n      // This is a special case to guard since we want ui to show the status\n      // but not to emit a event\n      if (draggingNode.key === droppingNode.key) {\n        return;\n      }\n      // Bailout 3\n      // insert before its next node\n      // insert after its prev node\n      if (droppingPosition === 'before') {\n        const nextNode = draggingNode.getNext({\n          includeDisabled: true\n        });\n        if (nextNode) {\n          if (nextNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n      if (droppingPosition === 'after') {\n        const prevNode = draggingNode.getPrev({\n          includeDisabled: true\n        });\n        if (prevNode) {\n          if (prevNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n      doDrop({\n        event,\n        node: droppingNode.rawNode,\n        dragNode: draggingNode.rawNode,\n        dropPosition\n      });\n      resetDndState();\n    }\n    function handleScroll() {\n      syncScrollbar();\n    }\n    function handleResize() {\n      syncScrollbar();\n    }\n    function handleFocusout(e) {\n      var _a;\n      if (props.virtualScroll || props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n          return;\n        }\n        pendingNodeKeyRef.value = null;\n      } else {\n        const {\n          value: selfEl\n        } = selfElRef;\n        if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget)) return;\n        pendingNodeKeyRef.value = null;\n      }\n    }\n    watch(pendingNodeKeyRef, value => {\n      var _a, _b;\n      if (value === null) return;\n      if (props.virtualScroll) {\n        (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({\n          key: value\n        });\n      } else if (props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if (scrollbarInst === null) return;\n        const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n        if (!targetEl) return;\n        scrollbarInst.scrollTo({\n          el: targetEl\n        });\n      }\n    });\n    provide(treeInjectionKey, {\n      loadingKeysRef,\n      highlightKeySetRef: mergedHighlightKeySetRef,\n      displayedCheckedKeysRef,\n      displayedIndeterminateKeysRef,\n      mergedSelectedKeysRef,\n      mergedExpandedKeysRef,\n      mergedThemeRef: themeRef,\n      mergedCheckStrategyRef,\n      nodePropsRef: toRef(props, 'nodeProps'),\n      disabledRef: toRef(props, 'disabled'),\n      checkableRef: toRef(props, 'checkable'),\n      selectableRef: toRef(props, 'selectable'),\n      expandOnClickRef: toRef(props, 'expandOnClick'),\n      onLoadRef: toRef(props, 'onLoad'),\n      draggableRef: toRef(props, 'draggable'),\n      blockLineRef: toRef(props, 'blockLine'),\n      indentRef: toRef(props, 'indent'),\n      cascadeRef: toRef(props, 'cascade'),\n      checkOnClickRef: toRef(props, 'checkOnClick'),\n      checkboxPlacementRef: props.checkboxPlacement,\n      droppingMouseNodeRef,\n      droppingNodeParentRef,\n      draggingNodeRef,\n      droppingPositionRef,\n      droppingOffsetLevelRef,\n      fNodesRef,\n      pendingNodeKeyRef,\n      showLineRef: toRef(props, 'showLine'),\n      disabledFieldRef: toRef(props, 'disabledField'),\n      internalScrollableRef: toRef(props, 'internalScrollable'),\n      internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n      internalTreeSelect: props.internalTreeSelect,\n      renderLabelRef: toRef(props, 'renderLabel'),\n      renderPrefixRef: toRef(props, 'renderPrefix'),\n      renderSuffixRef: toRef(props, 'renderSuffix'),\n      renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n      labelFieldRef: toRef(props, 'labelField'),\n      multipleRef: toRef(props, 'multiple'),\n      overrideDefaultNodeClickBehaviorRef: toRef(props, 'overrideDefaultNodeClickBehavior'),\n      handleSwitcherClick,\n      handleDragEnd,\n      handleDragEnter,\n      handleDragLeave,\n      handleDragStart,\n      handleDrop,\n      handleDragOver,\n      handleSelect,\n      handleCheck\n    });\n    function scrollTo(options, y) {\n      var _a, _b;\n      if (typeof options === 'number') {\n        (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options, y || 0);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        (_b = virtualListInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(options);\n      }\n    }\n    const exposedMethods = {\n      handleKeydown,\n      scrollTo,\n      getCheckedData: () => {\n        if (!props.checkable) return {\n          keys: [],\n          options: []\n        };\n        const {\n          checkedKeys\n        } = checkedStatusRef.value;\n        return {\n          keys: checkedKeys,\n          options: getOptionsByKeys(checkedKeys)\n        };\n      },\n      getIndeterminateData: () => {\n        if (!props.checkable) return {\n          keys: [],\n          options: []\n        };\n        const {\n          indeterminateKeys\n        } = checkedStatusRef.value;\n        return {\n          keys: indeterminateKeys,\n          options: getOptionsByKeys(indeterminateKeys)\n        };\n      }\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          fontSize,\n          nodeBorderRadius,\n          nodeColorHover,\n          nodeColorPressed,\n          nodeColorActive,\n          arrowColor,\n          loadingColor,\n          nodeTextColor,\n          nodeTextColorDisabled,\n          dropMarkColor,\n          nodeWrapperPadding,\n          nodeHeight,\n          lineHeight,\n          lineColor\n        }\n      } = themeRef.value;\n      const lineOffsetTop = getPadding(nodeWrapperPadding, 'top');\n      const lineOffsetBottom = getPadding(nodeWrapperPadding, 'bottom');\n      const nodeContentHeight = pxfy(depx(nodeHeight) - depx(lineOffsetTop) - depx(lineOffsetBottom));\n      return {\n        '--n-arrow-color': arrowColor,\n        '--n-loading-color': loadingColor,\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-font-size': fontSize,\n        '--n-node-border-radius': nodeBorderRadius,\n        '--n-node-color-active': nodeColorActive,\n        '--n-node-color-hover': nodeColorHover,\n        '--n-node-color-pressed': nodeColorPressed,\n        '--n-node-text-color': nodeTextColor,\n        '--n-node-text-color-disabled': nodeTextColorDisabled,\n        '--n-drop-mark-color': dropMarkColor,\n        '--n-node-wrapper-padding': nodeWrapperPadding,\n        '--n-line-offset-top': `-${lineOffsetTop}`,\n        '--n-line-offset-bottom': `-${lineOffsetBottom}`,\n        '--n-node-content-height': nodeContentHeight,\n        '--n-line-height': lineHeight,\n        '--n-line-color': lineColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tree', undefined, cssVarsRef, props) : undefined;\n    return Object.assign(Object.assign({}, exposedMethods), {\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedTheme: themeRef,\n      rtlEnabled: rtlEnabledRef,\n      fNodes: mergedFNodesRef,\n      aip: aipRef,\n      selfElRef,\n      virtualListInstRef,\n      scrollbarInstRef,\n      handleFocusout,\n      handleDragLeaveTree,\n      handleScroll,\n      getScrollContainer,\n      getScrollContent,\n      handleAfterEnter,\n      handleResize,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n  render() {\n    var _a;\n    const {\n      fNodes,\n      internalRenderEmpty\n    } = this;\n    if (!fNodes.length && internalRenderEmpty) {\n      return internalRenderEmpty();\n    }\n    const {\n      mergedClsPrefix,\n      blockNode,\n      blockLine,\n      draggable,\n      disabled,\n      internalFocusable,\n      checkable,\n      handleKeydown,\n      rtlEnabled,\n      handleFocusout,\n      scrollbarProps\n    } = this;\n    const mergedFocusable = internalFocusable && !disabled;\n    const tabindex = mergedFocusable ? '0' : undefined;\n    const treeClass = [`${mergedClsPrefix}-tree`, rtlEnabled && `${mergedClsPrefix}-tree--rtl`, checkable && `${mergedClsPrefix}-tree--checkable`, (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`, blockLine && `${mergedClsPrefix}-tree--block-line`];\n    const createNode = tmNode => {\n      return '__motion' in tmNode ? h(MotionWrapper, {\n        height: tmNode.height,\n        nodes: tmNode.nodes,\n        clsPrefix: mergedClsPrefix,\n        mode: tmNode.mode,\n        onAfterEnter: this.handleAfterEnter\n      }) : h(NTreeNode, {\n        key: tmNode.key,\n        tmNode: tmNode,\n        clsPrefix: mergedClsPrefix\n      });\n    };\n    if (this.virtualScroll) {\n      const {\n        mergedTheme,\n        internalScrollablePadding\n      } = this;\n      const padding = getPadding(internalScrollablePadding || '0');\n      return h(NxScrollbar, Object.assign({}, scrollbarProps, {\n        ref: \"scrollbarInstRef\",\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n        container: this.getScrollContainer,\n        content: this.getScrollContent,\n        class: treeClass,\n        theme: mergedTheme.peers.Scrollbar,\n        themeOverrides: mergedTheme.peerOverrides.Scrollbar,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined\n      }), {\n        default: () => {\n          var _a;\n          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n          return !fNodes.length ? resolveSlot(this.$slots.empty, () => [h(NEmpty, {\n            class: `${mergedClsPrefix}-tree__empty`,\n            theme: this.mergedTheme.peers.Empty,\n            themeOverrides: this.mergedTheme.peerOverrides.Empty\n          })]) : h(VVirtualList, {\n            ref: \"virtualListInstRef\",\n            items: this.fNodes,\n            itemSize: depx(mergedTheme.self.nodeHeight),\n            ignoreItemResize: this.aip,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            class: this.themeClass,\n            style: [this.cssVars, {\n              paddingLeft: padding.left,\n              paddingRight: padding.right\n            }],\n            onScroll: this.handleScroll,\n            onResize: this.handleResize,\n            showScrollbar: false,\n            itemResizable: true\n          }, {\n            default: ({\n              item\n            }) => createNode(item)\n          });\n        }\n      });\n    }\n    const {\n      internalScrollable\n    } = this;\n    treeClass.push(this.themeClass);\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (internalScrollable) {\n      return h(NxScrollbar, Object.assign({}, scrollbarProps, {\n        class: treeClass,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        style: this.cssVars,\n        contentStyle: {\n          padding: this.internalScrollablePadding\n        }\n      }), {\n        default: () => h(\"div\", {\n          onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n          ref: \"selfElRef\"\n        }, this.fNodes.map(createNode))\n      });\n    } else {\n      return h(\"div\", {\n        class: treeClass,\n        tabindex: tabindex,\n        ref: \"selfElRef\",\n        style: this.cssVars,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined\n      }, !fNodes.length ? resolveSlot(this.$slots.empty, () => [h(NEmpty, {\n        class: `${mergedClsPrefix}-tree__empty`,\n        theme: this.mergedTheme.peers.Empty,\n        themeOverrides: this.mergedTheme.peerOverrides.Empty\n      })]) : fNodes.map(createNode));\n    }\n  }\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","h","ref","toRef","computed","defineComponent","provide","watch","nextTick","watchEffect","inject","createTreeMate","flatten","createIndexGetter","useMergedState","VVirtualList","depx","getPadding","pxfy","treeSelectInjectionKey","useConfig","useTheme","useThemeClass","useRtl","call","createDataKey","resolveSlot","warn","warnOnce","NxScrollbar","treeLight","NEmpty","NTreeNode","keysWithFilter","emptyImage","filterTree","isNodeDisabled","useMergedCheckStrategy","useKeyboard","treeInjectionKey","MotionWrapper","defaultAllowDrop","style","createTreeMateOptions","keyField","childrenField","disabledField","getChildren","settledGetChildren","node","getIsGroup","getKey","getDisabled","checkboxDisabled","treeSharedProps","allowCheckingNotLoaded","Boolean","filter","Function","defaultExpandAll","expandedKeys","Array","type","String","default","labelField","defaultExpandedKeys","indeterminateKeys","renderSwitcherIcon","onUpdateIndeterminateKeys","onUpdateExpandedKeys","overrideDefaultNodeClickBehavior","treeProps","Object","assign","props","accordion","showIrrelevantNodes","data","expandOnDragenter","expandOnClick","checkOnClick","cancelable","checkable","draggable","blockNode","blockLine","showLine","disabled","checkedKeys","defaultCheckedKeys","selectedKeys","defaultSelectedKeys","multiple","pattern","onLoad","cascade","selectable","scrollbarProps","indent","Number","allowDrop","animated","checkboxPlacement","virtualScroll","watchProps","renderLabel","renderPrefix","renderSuffix","nodeProps","keyboard","onDragenter","onDragleave","onDragend","onDragstart","onDragover","onDrop","onUpdateCheckedKeys","onUpdateSelectedKeys","internalTreeSelect","internalScrollable","internalScrollablePadding","internalRenderEmpty","internalHighlightKeySet","internalUnifySelectCheck","internalCheckboxFocusable","internalFocusable","checkStrategy","leafOnly","name","setup","process","env","NODE_ENV","mergedClsPrefixRef","inlineThemeDisabled","mergedRtlRef","rtlEnabledRef","themeRef","selfElRef","scrollbarInstRef","virtualListInstRef","getScrollContainer","_a","listElRef","getScrollContent","itemsElRef","mergedFilterRef","length","label","toLowerCase","includes","filteredTreeInfoRef","filteredTree","highlightKeySet","undefined","displayTreeMateRef","treeSelectInjection","dataTreeMateRef","dataTreeMate","uncontrolledCheckedKeysRef","controlledCheckedKeysRef","mergedCheckedKeysRef","checkedStatusRef","getCheckedKeys","allowNotLoaded","mergedCheckStrategyRef","displayedCheckedKeysRef","displayedIndeterminateKeysRef","uncontrolledSelectedKeysRef","controlledSelectedKeysRef","mergedSelectedKeysRef","uncontrolledExpandedKeysRef","initUncontrolledExpandedKeys","keys","getNonLeafKeys","controlledExpandedKeysRef","mergedExpandedKeysRef","fNodesRef","getFlattenedNodes","pendingNodeKeyRef","handleKeydown","handleCheck","handleSelect","handleSwitcherClick","expandTimerId","nodeKeyToBeExpanded","uncontrolledHighlightKeySetRef","Set","controlledHighlightKeySetRef","mergedHighlightKeySetRef","loadingKeysRef","expandedNonLoadingKeysRef","key","has","dragStartX","draggingNodeRef","droppingNodeRef","droppingMouseNodeRef","droppingPositionRef","droppingOffsetLevelRef","droppingNodeParentRef","droppingNode","parent","isDataReset","clear","resetDndState","deep","expandAnimationDisabled","disableExpandAnimationForOneTick","memoizedExpandedKeys","oldValue","expandedKeysAfterChange","doUpdateExpandedKeys","getOptionsByKeys","action","triggerLoading","loadingKeys","add","loadResult","rawNode","resetDragExpandState","loadError","console","error","delete","displayTreeMate","getNode","forEach","shallowLoaded","aipRef","afNodesRef","prevValue","syncScrollbar","nodeHeight","self","prevVSet","addedKey","removedKey","expandedKey","currentVSet","viewportHeight","offsetHeight","viewportItemCount","Math","ceil","baseExpandedKeys","expandedNodeIndex","findIndex","children","expandedChildren","splice","__motion","mode","height","nodes","slice","collapsedNodeIndex","collapsedNodeChildren","collapsedChildren","getFIndexRef","mergedFNodesRef","scrollbarInst","sync","handleAfterEnter","map","option","meta","_onUpdateExpandedKeys","doUpdateCheckedKeys","_onUpdateCheckedKeys","doUpdateIndeterminateKeys","_onUpdateIndeterminateKeys","doUpdateSelectedKeys","_onUpdateSelectedKeys","doDragEnter","info","doDragLeave","doDragEnd","doDragStart","doDragOver","doDrop","resetDragState","resetDropState","window","clearTimeout","checked","checkedAction","toggleExpand","mergedExpandedKeys","index","expandNodeId","from","nodeToBeExpanded","isLeaf","nextKeys","siblingKeySet","siblings","push","concat","expandDragEnterNode","expand","droppingMouseNode","setTimeout","handleDragEnter","event","handleDragOver","handleDragLeave","handleDragLeaveTree","target","currentTarget","handleDragEnd","handleDragStart","dataTransfer","setDragImage","clientX","emit","draggingNode","el","elOffsetHeight","top","elClientTop","getBoundingClientRect","eventOffsetY","clientY","mousePosition","allowDropInside","dropPosition","phase","getFindex","finalDropNode","finalDropPosition","hoverNodeFIndex","mouseAtExpandedNonLeafNode","isFirstChild","isLastChild","offset","offsetLevel","contains","handleDrop","droppingPosition","nextNode","getNext","includeDisabled","prevNode","getPrev","dragNode","handleScroll","handleResize","handleFocusout","containerRef","relatedTarget","selfEl","_b","scrollTo","targetEl","contentRef","querySelector","highlightKeySetRef","mergedThemeRef","nodePropsRef","disabledRef","checkableRef","selectableRef","expandOnClickRef","onLoadRef","draggableRef","blockLineRef","indentRef","cascadeRef","checkOnClickRef","checkboxPlacementRef","showLineRef","disabledFieldRef","internalScrollableRef","internalCheckboxFocusableRef","renderLabelRef","renderPrefixRef","renderSuffixRef","renderSwitcherIconRef","labelFieldRef","multipleRef","overrideDefaultNodeClickBehaviorRef","options","y","exposedMethods","getCheckedData","getIndeterminateData","cssVarsRef","common","cubicBezierEaseInOut","fontSize","nodeBorderRadius","nodeColorHover","nodeColorPressed","nodeColorActive","arrowColor","loadingColor","nodeTextColor","nodeTextColorDisabled","dropMarkColor","nodeWrapperPadding","lineHeight","lineColor","lineOffsetTop","lineOffsetBottom","nodeContentHeight","themeClassHandle","mergedClsPrefix","mergedTheme","rtlEnabled","fNodes","aip","cssVars","themeClass","onRender","render","mergedFocusable","tabindex","treeClass","createNode","tmNode","clsPrefix","onAfterEnter","padding","container","content","class","theme","peers","Scrollbar","themeOverrides","peerOverrides","onKeydown","onFocusout","$slots","empty","Empty","items","itemSize","ignoreItemResize","paddingTop","paddingBottom","bottom","paddingLeft","left","paddingRight","right","onScroll","onResize","showScrollbar","itemResizable","item","contentStyle"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/naive-ui/es/tree/src/Tree.mjs"],"sourcesContent":["var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect, inject } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { depx, getPadding, pxfy } from 'seemly';\nimport { treeSelectInjectionKey } from \"../../tree-select/src/interface.mjs\";\nimport { useConfig, useTheme, useThemeClass, useRtl } from \"../../_mixins/index.mjs\";\nimport { call, createDataKey, resolveSlot, warn, warnOnce } from \"../../_utils/index.mjs\";\nimport { NxScrollbar } from \"../../_internal/index.mjs\";\nimport { treeLight } from \"../styles/index.mjs\";\nimport { NEmpty } from \"../../empty/index.mjs\";\nimport NTreeNode from \"./TreeNode.mjs\";\nimport { keysWithFilter, emptyImage, filterTree, isNodeDisabled, useMergedCheckStrategy } from \"./utils.mjs\";\nimport { useKeyboard } from \"./keyboard.mjs\";\nimport { treeInjectionKey } from \"./interface.mjs\";\nimport MotionWrapper from \"./MotionWrapper.mjs\";\nimport { defaultAllowDrop } from \"./dnd.mjs\";\nimport style from \"./styles/index.cssr.mjs\";\nexport function createTreeMateOptions(keyField, childrenField, disabledField, getChildren) {\n  const settledGetChildren = getChildren || (node => {\n    return node[childrenField];\n  });\n  return {\n    getIsGroup() {\n      return false;\n    },\n    getKey(node) {\n      return node[keyField];\n    },\n    getChildren: settledGetChildren,\n    getDisabled(node) {\n      return !!(node[disabledField] || node.checkboxDisabled);\n    }\n  };\n}\nexport const treeSharedProps = {\n  allowCheckingNotLoaded: Boolean,\n  filter: Function,\n  defaultExpandAll: Boolean,\n  expandedKeys: Array,\n  keyField: {\n    type: String,\n    default: 'key'\n  },\n  labelField: {\n    type: String,\n    default: 'label'\n  },\n  childrenField: {\n    type: String,\n    default: 'children'\n  },\n  disabledField: {\n    type: String,\n    default: 'disabled'\n  },\n  defaultExpandedKeys: {\n    type: Array,\n    default: () => []\n  },\n  indeterminateKeys: Array,\n  renderSwitcherIcon: Function,\n  onUpdateIndeterminateKeys: [Function, Array],\n  'onUpdate:indeterminateKeys': [Function, Array],\n  onUpdateExpandedKeys: [Function, Array],\n  'onUpdate:expandedKeys': [Function, Array],\n  overrideDefaultNodeClickBehavior: Function\n};\nexport const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {\n  accordion: Boolean,\n  showIrrelevantNodes: {\n    type: Boolean,\n    default: true\n  },\n  data: {\n    type: Array,\n    default: () => []\n  },\n  expandOnDragenter: {\n    type: Boolean,\n    default: true\n  },\n  expandOnClick: Boolean,\n  checkOnClick: {\n    type: [Boolean, Function],\n    default: false\n  },\n  cancelable: {\n    type: Boolean,\n    default: true\n  },\n  checkable: Boolean,\n  draggable: Boolean,\n  blockNode: Boolean,\n  blockLine: Boolean,\n  showLine: Boolean,\n  disabled: Boolean,\n  checkedKeys: Array,\n  defaultCheckedKeys: {\n    type: Array,\n    default: () => []\n  },\n  selectedKeys: Array,\n  defaultSelectedKeys: {\n    type: Array,\n    default: () => []\n  },\n  multiple: Boolean,\n  pattern: {\n    type: String,\n    default: ''\n  },\n  onLoad: Function,\n  cascade: Boolean,\n  selectable: {\n    type: Boolean,\n    default: true\n  },\n  scrollbarProps: Object,\n  indent: {\n    type: Number,\n    default: 24\n  },\n  allowDrop: {\n    type: Function,\n    default: defaultAllowDrop\n  },\n  animated: {\n    type: Boolean,\n    default: true\n  },\n  checkboxPlacement: {\n    type: String,\n    default: 'left'\n  },\n  virtualScroll: Boolean,\n  watchProps: Array,\n  renderLabel: Function,\n  renderPrefix: Function,\n  renderSuffix: Function,\n  nodeProps: Function,\n  keyboard: {\n    type: Boolean,\n    default: true\n  },\n  getChildren: Function,\n  onDragenter: [Function, Array],\n  onDragleave: [Function, Array],\n  onDragend: [Function, Array],\n  onDragstart: [Function, Array],\n  onDragover: [Function, Array],\n  onDrop: [Function, Array],\n  onUpdateCheckedKeys: [Function, Array],\n  'onUpdate:checkedKeys': [Function, Array],\n  onUpdateSelectedKeys: [Function, Array],\n  'onUpdate:selectedKeys': [Function, Array]\n}), treeSharedProps), {\n  // internal props for tree-select\n  internalTreeSelect: Boolean,\n  internalScrollable: Boolean,\n  internalScrollablePadding: String,\n  // use it to display\n  internalRenderEmpty: Function,\n  internalHighlightKeySet: Object,\n  internalUnifySelectCheck: Boolean,\n  internalCheckboxFocusable: {\n    type: Boolean,\n    default: true\n  },\n  internalFocusable: {\n    // Make tree-select take over keyboard operations\n    type: Boolean,\n    default: true\n  },\n  checkStrategy: {\n    type: String,\n    default: 'all'\n  },\n  /**\n   * @deprecated\n   */\n  leafOnly: Boolean\n});\nexport default defineComponent({\n  name: 'Tree',\n  props: treeProps,\n  setup(props) {\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.leafOnly) {\n          warnOnce('tree', '`leaf-only` is deprecated, please use `check-strategy=\"child\"` instead');\n        }\n      });\n    }\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled,\n      mergedRtlRef\n    } = useConfig(props);\n    const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);\n    const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n    const selfElRef = ref(null);\n    const scrollbarInstRef = ref(null);\n    const virtualListInstRef = ref(null);\n    function getScrollContainer() {\n      var _a;\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n    }\n    function getScrollContent() {\n      var _a;\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n    }\n    const mergedFilterRef = computed(() => {\n      const {\n        filter\n      } = props;\n      if (filter) return filter;\n      const {\n        labelField\n      } = props;\n      return (pattern, node) => {\n        if (!pattern.length) return true;\n        const label = node[labelField];\n        if (typeof label === 'string') {\n          return label.toLowerCase().includes(pattern.toLowerCase());\n        }\n        return false;\n      };\n    });\n    const filteredTreeInfoRef = computed(() => {\n      const {\n        pattern\n      } = props;\n      if (!pattern) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n      if (!pattern.length || !mergedFilterRef.value) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n      return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);\n    });\n    // We don't expect data source to change so we just determine it once\n    const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes ? props.data : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, props.getChildren)));\n    const treeSelectInjection = inject(treeSelectInjectionKey, null);\n    const dataTreeMateRef = props.internalTreeSelect ? treeSelectInjection.dataTreeMate : displayTreeMateRef;\n    const {\n      watchProps\n    } = props;\n    const uncontrolledCheckedKeysRef = ref([]);\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n      watchEffect(() => {\n        uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n      });\n    } else {\n      uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n    }\n    const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n    const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n    const checkedStatusRef = computed(() => {\n      const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      return value;\n    });\n    const mergedCheckStrategyRef = useMergedCheckStrategy(props);\n    const displayedCheckedKeysRef = computed(() => {\n      return checkedStatusRef.value.checkedKeys;\n    });\n    const displayedIndeterminateKeysRef = computed(() => {\n      const {\n        indeterminateKeys\n      } = props;\n      if (indeterminateKeys !== undefined) return indeterminateKeys;\n      return checkedStatusRef.value.indeterminateKeys;\n    });\n    const uncontrolledSelectedKeysRef = ref([]);\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n      watchEffect(() => {\n        uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n      });\n    } else {\n      uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n    }\n    const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n    const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n    const uncontrolledExpandedKeysRef = ref([]);\n    const initUncontrolledExpandedKeys = keys => {\n      uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys === undefined ? props.defaultExpandedKeys : keys;\n    };\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n      // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n      watchEffect(() => {\n        initUncontrolledExpandedKeys(undefined);\n      });\n    } else {\n      // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n      watchEffect(() => {\n        initUncontrolledExpandedKeys(props.defaultExpandedKeys);\n      });\n    }\n    const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n    const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n    const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n    const {\n      pendingNodeKeyRef,\n      handleKeydown\n    } = useKeyboard({\n      props,\n      mergedCheckedKeysRef,\n      mergedSelectedKeysRef,\n      fNodesRef,\n      mergedExpandedKeysRef,\n      handleCheck,\n      handleSelect,\n      handleSwitcherClick\n    });\n    let expandTimerId = null;\n    let nodeKeyToBeExpanded = null;\n    const uncontrolledHighlightKeySetRef = ref(new Set());\n    const controlledHighlightKeySetRef = computed(() => {\n      return props.internalHighlightKeySet || filteredTreeInfoRef.value.highlightKeySet;\n    });\n    const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n    const loadingKeysRef = ref(new Set());\n    const expandedNonLoadingKeysRef = computed(() => {\n      return mergedExpandedKeysRef.value.filter(key => !loadingKeysRef.value.has(key));\n    });\n    let dragStartX = 0;\n    const draggingNodeRef = ref(null);\n    const droppingNodeRef = ref(null);\n    const droppingMouseNodeRef = ref(null);\n    const droppingPositionRef = ref(null);\n    const droppingOffsetLevelRef = ref(0);\n    const droppingNodeParentRef = computed(() => {\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      if (!droppingNode) return null;\n      // May avoid overlap between line mark of first child & rect mark of parent\n      // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n      //   return null\n      // }\n      return droppingNode.parent;\n    });\n    // shallow watch data\n    let isDataReset = false;\n    watch(toRef(props, 'data'), () => {\n      isDataReset = true;\n      void nextTick(() => {\n        isDataReset = false;\n      });\n      loadingKeysRef.value.clear();\n      pendingNodeKeyRef.value = null;\n      resetDndState();\n    }, {\n      deep: false\n    });\n    let expandAnimationDisabled = false;\n    const disableExpandAnimationForOneTick = () => {\n      expandAnimationDisabled = true;\n      void nextTick(() => {\n        expandAnimationDisabled = false;\n      });\n    };\n    let memoizedExpandedKeys;\n    watch(toRef(props, 'pattern'), (value, oldValue) => {\n      if (props.showIrrelevantNodes) {\n        memoizedExpandedKeys = undefined;\n        if (value) {\n          const {\n            expandedKeys: expandedKeysAfterChange,\n            highlightKeySet\n          } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n          uncontrolledHighlightKeySetRef.value = highlightKeySet;\n          disableExpandAnimationForOneTick();\n          doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {\n            node: null,\n            action: 'filter'\n          });\n        } else {\n          uncontrolledHighlightKeySetRef.value = new Set();\n        }\n      } else {\n        if (!value.length) {\n          if (memoizedExpandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys), {\n              node: null,\n              action: 'filter'\n            });\n          }\n        } else {\n          if (!oldValue.length) {\n            memoizedExpandedKeys = mergedExpandedKeysRef.value;\n          }\n          const {\n            expandedKeys\n          } = filteredTreeInfoRef.value;\n          if (expandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys), {\n              node: null,\n              action: 'filter'\n            });\n          }\n        }\n      }\n    });\n    function triggerLoading(node) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          onLoad\n        } = props;\n        if (!onLoad) {\n          if (process.env.NODE_ENV !== 'production') {\n            warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n          }\n          yield Promise.resolve();\n          return;\n        }\n        const {\n          value: loadingKeys\n        } = loadingKeysRef;\n        if (!loadingKeys.has(node.key)) {\n          loadingKeys.add(node.key);\n          try {\n            const loadResult = yield onLoad(node.rawNode);\n            if (loadResult === false) {\n              resetDragExpandState();\n            }\n          } catch (loadError) {\n            console.error(loadError);\n            resetDragExpandState();\n          }\n          loadingKeys.delete(node.key);\n        }\n      });\n    }\n    watchEffect(() => {\n      var _a;\n      const {\n        value: displayTreeMate\n      } = displayTreeMateRef;\n      if (!displayTreeMate) return;\n      const {\n        getNode\n      } = displayTreeMate;\n      (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach(key => {\n        const node = getNode(key);\n        if (node && !node.shallowLoaded) {\n          void triggerLoading(node);\n        }\n      });\n    });\n    // animation in progress\n    const aipRef = ref(false);\n    // animation flattened nodes\n    const afNodesRef = ref([]);\n    // Note: Since the virtual list depends on min height, if there's a node\n    // whose height starts from 0, the virtual list will have a wrong height\n    // during animation. This will seldom cause wired scrollbar status. It is\n    // fixable and need some changes in vueuc, I've no time so I just leave it\n    // here. Maybe the bug won't be fixed during the life time of the project.\n    watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n      if (!props.animated || expandAnimationDisabled) {\n        void nextTick(syncScrollbar);\n        return;\n      }\n      if (isDataReset) {\n        return;\n      }\n      const nodeHeight = depx(themeRef.value.self.nodeHeight);\n      const prevVSet = new Set(prevValue);\n      let addedKey = null;\n      let removedKey = null;\n      for (const expandedKey of value) {\n        if (!prevVSet.has(expandedKey)) {\n          if (addedKey !== null) return; // multi expand, not triggered by click\n          addedKey = expandedKey;\n        }\n      }\n      const currentVSet = new Set(value);\n      for (const expandedKey of prevValue) {\n        if (!currentVSet.has(expandedKey)) {\n          if (removedKey !== null) return; // multi collapse, not triggered by click\n          removedKey = expandedKey;\n        }\n      }\n      if (addedKey === null && removedKey === null) {\n        // 1. multi action, not triggered by click\n        // 2. no action, don't know what happened\n        return;\n      }\n      const {\n        virtualScroll\n      } = props;\n      const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n      const viewportItemCount = Math.ceil(viewportHeight / nodeHeight) + 1;\n      // play add animation\n      let baseExpandedKeys;\n      if (addedKey !== null) {\n        baseExpandedKeys = prevValue;\n      }\n      if (removedKey !== null) {\n        if (baseExpandedKeys === undefined) {\n          baseExpandedKeys = value;\n        } else {\n          baseExpandedKeys = baseExpandedKeys.filter(key => key !== removedKey);\n        }\n      }\n      aipRef.value = true;\n      afNodesRef.value = displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);\n      if (addedKey !== null) {\n        const expandedNodeIndex = afNodesRef.value.findIndex(node => node.key === addedKey);\n        if (~expandedNodeIndex) {\n          const children =\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          afNodesRef.value[expandedNodeIndex].children;\n          // sometimes user will pass leaf keys in\n          if (children) {\n            const expandedChildren = flatten(children, value);\n            afNodesRef.value.splice(expandedNodeIndex + 1, 0, {\n              __motion: true,\n              mode: 'expand',\n              height: virtualScroll ? expandedChildren.length * nodeHeight : undefined,\n              nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren\n            });\n          }\n        }\n      }\n      if (removedKey !== null) {\n        const collapsedNodeIndex = afNodesRef.value.findIndex(node => node.key === removedKey);\n        if (~collapsedNodeIndex) {\n          const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;\n          // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n          // but maybe children removed\n          if (!collapsedNodeChildren) return;\n          // play remove animation\n          aipRef.value = true;\n          const collapsedChildren = flatten(collapsedNodeChildren, value);\n          afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {\n            __motion: true,\n            mode: 'collapse',\n            height: virtualScroll ? collapsedChildren.length * nodeHeight : undefined,\n            nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren\n          });\n        }\n      }\n    });\n    const getFIndexRef = computed(() => {\n      return createIndexGetter(fNodesRef.value);\n    });\n    const mergedFNodesRef = computed(() => {\n      if (aipRef.value) return afNodesRef.value;else return fNodesRef.value;\n    });\n    function syncScrollbar() {\n      const {\n        value: scrollbarInst\n      } = scrollbarInstRef;\n      if (scrollbarInst) scrollbarInst.sync();\n    }\n    function handleAfterEnter() {\n      aipRef.value = false;\n      if (props.virtualScroll) {\n        // If virtual scroll, we won't listen to resize during animation, so\n        // resize callback of virtual list won't be called and as a result\n        // scrollbar won't sync. We need to sync scrollbar manually.\n        void nextTick(syncScrollbar);\n      }\n    }\n    function getOptionsByKeys(keys) {\n      const {\n        getNode\n      } = dataTreeMateRef.value;\n      return keys.map(key => {\n        var _a;\n        return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;\n      });\n    }\n    function doUpdateExpandedKeys(value, option, meta) {\n      const {\n        'onUpdate:expandedKeys': _onUpdateExpandedKeys,\n        onUpdateExpandedKeys\n      } = props;\n      uncontrolledExpandedKeysRef.value = value;\n      if (_onUpdateExpandedKeys) {\n        call(_onUpdateExpandedKeys, value, option, meta);\n      }\n      if (onUpdateExpandedKeys) {\n        call(onUpdateExpandedKeys, value, option, meta);\n      }\n    }\n    function doUpdateCheckedKeys(value, option, meta) {\n      const {\n        'onUpdate:checkedKeys': _onUpdateCheckedKeys,\n        onUpdateCheckedKeys\n      } = props;\n      uncontrolledCheckedKeysRef.value = value;\n      if (onUpdateCheckedKeys) {\n        call(onUpdateCheckedKeys, value, option, meta);\n      }\n      if (_onUpdateCheckedKeys) {\n        call(_onUpdateCheckedKeys, value, option, meta);\n      }\n    }\n    function doUpdateIndeterminateKeys(value, option) {\n      const {\n        'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys,\n        onUpdateIndeterminateKeys\n      } = props;\n      if (_onUpdateIndeterminateKeys) {\n        call(_onUpdateIndeterminateKeys, value, option);\n      }\n      if (onUpdateIndeterminateKeys) {\n        call(onUpdateIndeterminateKeys, value, option);\n      }\n    }\n    function doUpdateSelectedKeys(value, option, meta) {\n      const {\n        'onUpdate:selectedKeys': _onUpdateSelectedKeys,\n        onUpdateSelectedKeys\n      } = props;\n      uncontrolledSelectedKeysRef.value = value;\n      if (onUpdateSelectedKeys) {\n        call(onUpdateSelectedKeys, value, option, meta);\n      }\n      if (_onUpdateSelectedKeys) {\n        call(_onUpdateSelectedKeys, value, option, meta);\n      }\n    }\n    // Drag & Drop\n    function doDragEnter(info) {\n      const {\n        onDragenter\n      } = props;\n      if (onDragenter) call(onDragenter, info);\n    }\n    function doDragLeave(info) {\n      const {\n        onDragleave\n      } = props;\n      if (onDragleave) call(onDragleave, info);\n    }\n    function doDragEnd(info) {\n      const {\n        onDragend\n      } = props;\n      if (onDragend) call(onDragend, info);\n    }\n    function doDragStart(info) {\n      const {\n        onDragstart\n      } = props;\n      if (onDragstart) call(onDragstart, info);\n    }\n    function doDragOver(info) {\n      const {\n        onDragover\n      } = props;\n      if (onDragover) call(onDragover, info);\n    }\n    function doDrop(info) {\n      const {\n        onDrop\n      } = props;\n      if (onDrop) call(onDrop, info);\n    }\n    function resetDndState() {\n      resetDragState();\n      resetDropState();\n    }\n    function resetDragState() {\n      draggingNodeRef.value = null;\n    }\n    function resetDropState() {\n      droppingOffsetLevelRef.value = 0;\n      droppingNodeRef.value = null;\n      droppingMouseNodeRef.value = null;\n      droppingPositionRef.value = null;\n      resetDragExpandState();\n    }\n    function resetDragExpandState() {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n      nodeKeyToBeExpanded = null;\n    }\n    function handleCheck(node, checked) {\n      // We don't guard for leaf only since we have done it in view layer\n      if (props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      if (props.internalUnifySelectCheck && !props.multiple) {\n        handleSelect(node);\n        return;\n      }\n      const checkedAction = checked ? 'check' : 'uncheck';\n      const {\n        checkedKeys,\n        indeterminateKeys\n      } = dataTreeMateRef.value[checkedAction](node.key, displayedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        checkStrategy: mergedCheckStrategyRef.value,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys), {\n        node: node.rawNode,\n        action: checkedAction\n      });\n      doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n    }\n    function toggleExpand(node) {\n      if (props.disabled) return;\n      const {\n        key\n      } = node;\n      const {\n        value: mergedExpandedKeys\n      } = mergedExpandedKeysRef;\n      const index = mergedExpandedKeys.findIndex(expandNodeId => expandNodeId === key);\n      if (~index) {\n        const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n        expandedKeysAfterChange.splice(index, 1);\n        doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {\n          node: node.rawNode,\n          action: 'collapse'\n        });\n      } else {\n        const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n        if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n          return;\n        }\n        let nextKeys;\n        if (props.accordion) {\n          const siblingKeySet = new Set(node.siblings.map(({\n            key\n          }) => key));\n          nextKeys = mergedExpandedKeys.filter(expandedKey => {\n            return !siblingKeySet.has(expandedKey);\n          });\n          nextKeys.push(key);\n        } else {\n          nextKeys = mergedExpandedKeys.concat(key);\n        }\n        doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {\n          node: node.rawNode,\n          action: 'expand'\n        });\n      }\n    }\n    function handleSwitcherClick(node) {\n      if (props.disabled || aipRef.value) return;\n      toggleExpand(node);\n    }\n    function handleSelect(node) {\n      if (props.disabled || !props.selectable) {\n        return;\n      }\n      pendingNodeKeyRef.value = node.key;\n      if (props.internalUnifySelectCheck) {\n        const {\n          value: {\n            checkedKeys,\n            indeterminateKeys\n          }\n        } = checkedStatusRef;\n        if (props.multiple) {\n          handleCheck(node, !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key)));\n        } else {\n          doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]), {\n            node: node.rawNode,\n            action: 'check'\n          });\n        }\n      }\n      if (props.multiple) {\n        const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n        const index = selectedKeys.findIndex(key => key === node.key);\n        if (~index) {\n          if (props.cancelable) {\n            selectedKeys.splice(index, 1);\n          }\n        } else if (!~index) {\n          selectedKeys.push(node.key);\n        }\n        doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys), {\n          node: node.rawNode,\n          action: ~index ? 'unselect' : 'select'\n        });\n      } else {\n        const selectedKeys = mergedSelectedKeysRef.value;\n        if (selectedKeys.includes(node.key)) {\n          if (props.cancelable) {\n            doUpdateSelectedKeys([], [], {\n              node: node.rawNode,\n              action: 'unselect'\n            });\n          }\n        } else {\n          doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]), {\n            node: node.rawNode,\n            action: 'select'\n          });\n        }\n      }\n    }\n    function expandDragEnterNode(node) {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n      // Don't expand leaf node.\n      if (node.isLeaf) return;\n      nodeKeyToBeExpanded = node.key;\n      const expand = () => {\n        if (nodeKeyToBeExpanded !== node.key) return;\n        const {\n          value: droppingMouseNode\n        } = droppingMouseNodeRef;\n        if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {\n          const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n          doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {\n            node: node.rawNode,\n            action: 'expand'\n          });\n        }\n        expandTimerId = null;\n        nodeKeyToBeExpanded = null;\n      };\n      if (!node.shallowLoaded) {\n        expandTimerId = window.setTimeout(() => {\n          void triggerLoading(node).then(() => {\n            expand();\n          });\n        }, 1000);\n      } else {\n        expandTimerId = window.setTimeout(() => {\n          expand();\n        }, 1000);\n      }\n    }\n    // Dnd\n    function handleDragEnter({\n      event,\n      node\n    }) {\n      // node should be a tmNode\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      handleDragOver({\n        event,\n        node\n      }, false);\n      doDragEnter({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragLeave({\n      event,\n      node\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      doDragLeave({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragLeaveTree(e) {\n      if (e.target !== e.currentTarget) return;\n      resetDropState();\n    }\n    // Dragend is ok, we don't need to add global listener to reset drag status\n    function handleDragEnd({\n      event,\n      node\n    }) {\n      resetDndState();\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      doDragEnd({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragStart({\n      event,\n      node\n    }) {\n      var _a;\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      // Most of time, the image will block user's view\n      emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n      dragStartX = event.clientX;\n      draggingNodeRef.value = node;\n      doDragStart({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragOver({\n      event,\n      node\n    }, emit = true) {\n      var _a;\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      if (!draggingNode) return;\n      const {\n        allowDrop,\n        indent\n      } = props;\n      if (emit) doDragOver({\n        event,\n        node: node.rawNode\n      });\n      // Update dropping node\n      const el = event.currentTarget;\n      const {\n        height: elOffsetHeight,\n        top: elClientTop\n      } = el.getBoundingClientRect();\n      const eventOffsetY = event.clientY - elClientTop;\n      let mousePosition;\n      const allowDropInside = allowDrop({\n        node: node.rawNode,\n        dropPosition: 'inside',\n        phase: 'drag'\n      });\n      if (allowDropInside) {\n        if (eventOffsetY <= 8) {\n          mousePosition = 'before';\n        } else if (eventOffsetY >= elOffsetHeight - 8) {\n          mousePosition = 'after';\n        } else {\n          mousePosition = 'inside';\n        }\n      } else {\n        if (eventOffsetY <= elOffsetHeight / 2) {\n          mousePosition = 'before';\n        } else {\n          mousePosition = 'after';\n        }\n      }\n      const {\n        value: getFindex\n      } = getFIndexRef;\n      /** determine the drop position and drop node */\n      /** the dropping node needn't to be the mouse hovering node! */\n      /**\n       * if there is something i've learned from implementing a complex\n       * drag & drop. that is never write unit test before you really figure\n       * out what behavior is exactly you want.\n       */\n      let finalDropNode;\n      let finalDropPosition;\n      const hoverNodeFIndex = getFindex(node.key);\n      if (hoverNodeFIndex === null) {\n        resetDropState();\n        return;\n      }\n      let mouseAtExpandedNonLeafNode = false;\n      if (mousePosition === 'inside') {\n        finalDropNode = node;\n        finalDropPosition = 'inside';\n      } else {\n        if (mousePosition === 'before') {\n          if (node.isFirstChild) {\n            finalDropNode = node;\n            finalDropPosition = 'before';\n          } else {\n            finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n            finalDropPosition = 'after';\n          }\n        } else {\n          finalDropNode = node;\n          finalDropPosition = 'after';\n        }\n      }\n      // If the node is non-leaf and it is expanded, we don't allow it to\n      // drop after it and change it to drop before its next view sibling\n      if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n        mouseAtExpandedNonLeafNode = true;\n        if (finalDropPosition === 'after') {\n          finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n          if (!finalDropNode) {\n            // maybe there is no next view sibling when non-leaf node has no\n            // children and it is the last node in the tree\n            finalDropNode = node;\n            finalDropPosition = 'inside';\n          } else {\n            finalDropPosition = 'before';\n          }\n        }\n      }\n      const droppingMouseNode = finalDropNode;\n      droppingMouseNodeRef.value = droppingMouseNode;\n      // This is a speacial case, user is dragging a last child itself, so we\n      // only view it as they are trying to drop after it.\n      // There are some relevant codes in bailout 1's child branch.\n      // Also, the expand bailout should have a high priority. If it's non-leaf\n      // node and expanded, keep its origin drop position\n      if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {\n        finalDropPosition = 'after';\n      }\n      if (finalDropPosition === 'after') {\n        let offset = dragStartX - event.clientX; // drag left => > 0\n        let offsetLevel = 0;\n        while (offset >= indent / 2 &&\n        // divide by 2 to make it easier to trigger\n        finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {\n          offset -= indent;\n          offsetLevel += 1;\n          finalDropNode = finalDropNode.parent;\n        }\n        droppingOffsetLevelRef.value = offsetLevel;\n      } else {\n        droppingOffsetLevelRef.value = 0;\n      }\n      // Bailout 1\n      // Drag self into self\n      // Drag it into direct parent\n      if (draggingNode.contains(finalDropNode) || finalDropPosition === 'inside' && ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key) {\n        if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key) {\n          // This is special case that we want ui to show a mark to guide user\n          // to start dragging. Nor they will think nothing happens.\n          // However this is an invalid drop, we need to guard it inside\n          // handleDrop\n        } else {\n          resetDropState();\n          return;\n        }\n      }\n      // Bailout 3\n      if (!allowDrop({\n        node: finalDropNode.rawNode,\n        dropPosition: finalDropPosition,\n        phase: 'drag'\n      })) {\n        resetDropState();\n        return;\n      }\n      if (draggingNode.key === finalDropNode.key) {\n        // don't expand when drag on itself\n        resetDragExpandState();\n      } else {\n        if (nodeKeyToBeExpanded !== finalDropNode.key) {\n          if (finalDropPosition === 'inside') {\n            if (props.expandOnDragenter) {\n              expandDragEnterNode(finalDropNode);\n              // Bailout 4\n              // not try to loading\n              if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {\n                resetDndState();\n                return;\n              }\n            } else {\n              // Bailout 5\n              // never expands on drag\n              if (!finalDropNode.shallowLoaded) {\n                resetDndState();\n                return;\n              }\n            }\n          } else {\n            resetDragExpandState();\n          }\n        } else {\n          if (finalDropPosition !== 'inside') {\n            resetDragExpandState();\n          }\n        }\n      }\n      droppingPositionRef.value = finalDropPosition;\n      droppingNodeRef.value = finalDropNode;\n    }\n    function handleDrop({\n      event,\n      node,\n      dropPosition\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      const {\n        value: droppingPosition\n      } = droppingPositionRef;\n      if (!draggingNode || !droppingNode || !droppingPosition) {\n        return;\n      }\n      // Bailout 1\n      if (!props.allowDrop({\n        node: droppingNode.rawNode,\n        dropPosition: droppingPosition,\n        phase: 'drag'\n      })) {\n        return;\n      }\n      // Bailout 2\n      // This is a special case to guard since we want ui to show the status\n      // but not to emit a event\n      if (draggingNode.key === droppingNode.key) {\n        return;\n      }\n      // Bailout 3\n      // insert before its next node\n      // insert after its prev node\n      if (droppingPosition === 'before') {\n        const nextNode = draggingNode.getNext({\n          includeDisabled: true\n        });\n        if (nextNode) {\n          if (nextNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n      if (droppingPosition === 'after') {\n        const prevNode = draggingNode.getPrev({\n          includeDisabled: true\n        });\n        if (prevNode) {\n          if (prevNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n      doDrop({\n        event,\n        node: droppingNode.rawNode,\n        dragNode: draggingNode.rawNode,\n        dropPosition\n      });\n      resetDndState();\n    }\n    function handleScroll() {\n      syncScrollbar();\n    }\n    function handleResize() {\n      syncScrollbar();\n    }\n    function handleFocusout(e) {\n      var _a;\n      if (props.virtualScroll || props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n          return;\n        }\n        pendingNodeKeyRef.value = null;\n      } else {\n        const {\n          value: selfEl\n        } = selfElRef;\n        if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget)) return;\n        pendingNodeKeyRef.value = null;\n      }\n    }\n    watch(pendingNodeKeyRef, value => {\n      var _a, _b;\n      if (value === null) return;\n      if (props.virtualScroll) {\n        (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({\n          key: value\n        });\n      } else if (props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if (scrollbarInst === null) return;\n        const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n        if (!targetEl) return;\n        scrollbarInst.scrollTo({\n          el: targetEl\n        });\n      }\n    });\n    provide(treeInjectionKey, {\n      loadingKeysRef,\n      highlightKeySetRef: mergedHighlightKeySetRef,\n      displayedCheckedKeysRef,\n      displayedIndeterminateKeysRef,\n      mergedSelectedKeysRef,\n      mergedExpandedKeysRef,\n      mergedThemeRef: themeRef,\n      mergedCheckStrategyRef,\n      nodePropsRef: toRef(props, 'nodeProps'),\n      disabledRef: toRef(props, 'disabled'),\n      checkableRef: toRef(props, 'checkable'),\n      selectableRef: toRef(props, 'selectable'),\n      expandOnClickRef: toRef(props, 'expandOnClick'),\n      onLoadRef: toRef(props, 'onLoad'),\n      draggableRef: toRef(props, 'draggable'),\n      blockLineRef: toRef(props, 'blockLine'),\n      indentRef: toRef(props, 'indent'),\n      cascadeRef: toRef(props, 'cascade'),\n      checkOnClickRef: toRef(props, 'checkOnClick'),\n      checkboxPlacementRef: props.checkboxPlacement,\n      droppingMouseNodeRef,\n      droppingNodeParentRef,\n      draggingNodeRef,\n      droppingPositionRef,\n      droppingOffsetLevelRef,\n      fNodesRef,\n      pendingNodeKeyRef,\n      showLineRef: toRef(props, 'showLine'),\n      disabledFieldRef: toRef(props, 'disabledField'),\n      internalScrollableRef: toRef(props, 'internalScrollable'),\n      internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n      internalTreeSelect: props.internalTreeSelect,\n      renderLabelRef: toRef(props, 'renderLabel'),\n      renderPrefixRef: toRef(props, 'renderPrefix'),\n      renderSuffixRef: toRef(props, 'renderSuffix'),\n      renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n      labelFieldRef: toRef(props, 'labelField'),\n      multipleRef: toRef(props, 'multiple'),\n      overrideDefaultNodeClickBehaviorRef: toRef(props, 'overrideDefaultNodeClickBehavior'),\n      handleSwitcherClick,\n      handleDragEnd,\n      handleDragEnter,\n      handleDragLeave,\n      handleDragStart,\n      handleDrop,\n      handleDragOver,\n      handleSelect,\n      handleCheck\n    });\n    function scrollTo(options, y) {\n      var _a, _b;\n      if (typeof options === 'number') {\n        (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options, y || 0);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        (_b = virtualListInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(options);\n      }\n    }\n    const exposedMethods = {\n      handleKeydown,\n      scrollTo,\n      getCheckedData: () => {\n        if (!props.checkable) return {\n          keys: [],\n          options: []\n        };\n        const {\n          checkedKeys\n        } = checkedStatusRef.value;\n        return {\n          keys: checkedKeys,\n          options: getOptionsByKeys(checkedKeys)\n        };\n      },\n      getIndeterminateData: () => {\n        if (!props.checkable) return {\n          keys: [],\n          options: []\n        };\n        const {\n          indeterminateKeys\n        } = checkedStatusRef.value;\n        return {\n          keys: indeterminateKeys,\n          options: getOptionsByKeys(indeterminateKeys)\n        };\n      }\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          fontSize,\n          nodeBorderRadius,\n          nodeColorHover,\n          nodeColorPressed,\n          nodeColorActive,\n          arrowColor,\n          loadingColor,\n          nodeTextColor,\n          nodeTextColorDisabled,\n          dropMarkColor,\n          nodeWrapperPadding,\n          nodeHeight,\n          lineHeight,\n          lineColor\n        }\n      } = themeRef.value;\n      const lineOffsetTop = getPadding(nodeWrapperPadding, 'top');\n      const lineOffsetBottom = getPadding(nodeWrapperPadding, 'bottom');\n      const nodeContentHeight = pxfy(depx(nodeHeight) - depx(lineOffsetTop) - depx(lineOffsetBottom));\n      return {\n        '--n-arrow-color': arrowColor,\n        '--n-loading-color': loadingColor,\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-font-size': fontSize,\n        '--n-node-border-radius': nodeBorderRadius,\n        '--n-node-color-active': nodeColorActive,\n        '--n-node-color-hover': nodeColorHover,\n        '--n-node-color-pressed': nodeColorPressed,\n        '--n-node-text-color': nodeTextColor,\n        '--n-node-text-color-disabled': nodeTextColorDisabled,\n        '--n-drop-mark-color': dropMarkColor,\n        '--n-node-wrapper-padding': nodeWrapperPadding,\n        '--n-line-offset-top': `-${lineOffsetTop}`,\n        '--n-line-offset-bottom': `-${lineOffsetBottom}`,\n        '--n-node-content-height': nodeContentHeight,\n        '--n-line-height': lineHeight,\n        '--n-line-color': lineColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tree', undefined, cssVarsRef, props) : undefined;\n    return Object.assign(Object.assign({}, exposedMethods), {\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedTheme: themeRef,\n      rtlEnabled: rtlEnabledRef,\n      fNodes: mergedFNodesRef,\n      aip: aipRef,\n      selfElRef,\n      virtualListInstRef,\n      scrollbarInstRef,\n      handleFocusout,\n      handleDragLeaveTree,\n      handleScroll,\n      getScrollContainer,\n      getScrollContent,\n      handleAfterEnter,\n      handleResize,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n  render() {\n    var _a;\n    const {\n      fNodes,\n      internalRenderEmpty\n    } = this;\n    if (!fNodes.length && internalRenderEmpty) {\n      return internalRenderEmpty();\n    }\n    const {\n      mergedClsPrefix,\n      blockNode,\n      blockLine,\n      draggable,\n      disabled,\n      internalFocusable,\n      checkable,\n      handleKeydown,\n      rtlEnabled,\n      handleFocusout,\n      scrollbarProps\n    } = this;\n    const mergedFocusable = internalFocusable && !disabled;\n    const tabindex = mergedFocusable ? '0' : undefined;\n    const treeClass = [`${mergedClsPrefix}-tree`, rtlEnabled && `${mergedClsPrefix}-tree--rtl`, checkable && `${mergedClsPrefix}-tree--checkable`, (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`, blockLine && `${mergedClsPrefix}-tree--block-line`];\n    const createNode = tmNode => {\n      return '__motion' in tmNode ? h(MotionWrapper, {\n        height: tmNode.height,\n        nodes: tmNode.nodes,\n        clsPrefix: mergedClsPrefix,\n        mode: tmNode.mode,\n        onAfterEnter: this.handleAfterEnter\n      }) : h(NTreeNode, {\n        key: tmNode.key,\n        tmNode: tmNode,\n        clsPrefix: mergedClsPrefix\n      });\n    };\n    if (this.virtualScroll) {\n      const {\n        mergedTheme,\n        internalScrollablePadding\n      } = this;\n      const padding = getPadding(internalScrollablePadding || '0');\n      return h(NxScrollbar, Object.assign({}, scrollbarProps, {\n        ref: \"scrollbarInstRef\",\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n        container: this.getScrollContainer,\n        content: this.getScrollContent,\n        class: treeClass,\n        theme: mergedTheme.peers.Scrollbar,\n        themeOverrides: mergedTheme.peerOverrides.Scrollbar,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined\n      }), {\n        default: () => {\n          var _a;\n          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n          return !fNodes.length ? resolveSlot(this.$slots.empty, () => [h(NEmpty, {\n            class: `${mergedClsPrefix}-tree__empty`,\n            theme: this.mergedTheme.peers.Empty,\n            themeOverrides: this.mergedTheme.peerOverrides.Empty\n          })]) : h(VVirtualList, {\n            ref: \"virtualListInstRef\",\n            items: this.fNodes,\n            itemSize: depx(mergedTheme.self.nodeHeight),\n            ignoreItemResize: this.aip,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            class: this.themeClass,\n            style: [this.cssVars, {\n              paddingLeft: padding.left,\n              paddingRight: padding.right\n            }],\n            onScroll: this.handleScroll,\n            onResize: this.handleResize,\n            showScrollbar: false,\n            itemResizable: true\n          }, {\n            default: ({\n              item\n            }) => createNode(item)\n          });\n        }\n      });\n    }\n    const {\n      internalScrollable\n    } = this;\n    treeClass.push(this.themeClass);\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (internalScrollable) {\n      return h(NxScrollbar, Object.assign({}, scrollbarProps, {\n        class: treeClass,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        style: this.cssVars,\n        contentStyle: {\n          padding: this.internalScrollablePadding\n        }\n      }), {\n        default: () => h(\"div\", {\n          onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n          ref: \"selfElRef\"\n        }, this.fNodes.map(createNode))\n      });\n    } else {\n      return h(\"div\", {\n        class: treeClass,\n        tabindex: tabindex,\n        ref: \"selfElRef\",\n        style: this.cssVars,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined\n      }, !fNodes.length ? resolveSlot(this.$slots.empty, () => [h(NEmpty, {\n        class: `${mergedClsPrefix}-tree__empty`,\n        theme: this.mergedTheme.peers.Empty,\n        themeOverrides: this.mergedTheme.peerOverrides.Empty\n      })]) : fNodes.map(createNode));\n    }\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}