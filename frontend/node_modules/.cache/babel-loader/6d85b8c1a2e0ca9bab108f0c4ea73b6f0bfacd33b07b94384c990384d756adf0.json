{"ast":null,"code":"/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { defineComponent, renderSlot, h, onMounted, ref, nextTick } from 'vue';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nconst hiddenAttr = 'v-hidden';\nconst style = c('[v-hidden]', {\n  display: 'none!important'\n});\nexport default defineComponent({\n  name: 'Overflow',\n  props: {\n    getCounter: Function,\n    getTail: Function,\n    updateCounter: Function,\n    onUpdateCount: Function,\n    onUpdateOverflow: Function\n  },\n  setup(props, {\n    slots\n  }) {\n    const selfRef = ref(null);\n    const counterRef = ref(null);\n    function deriveCounter(options) {\n      const {\n        value: self\n      } = selfRef;\n      const {\n        getCounter,\n        getTail\n      } = props;\n      let counter;\n      if (getCounter !== undefined) counter = getCounter();else {\n        counter = counterRef.value;\n      }\n      if (!self || !counter) return;\n      if (counter.hasAttribute(hiddenAttr)) {\n        counter.removeAttribute(hiddenAttr);\n      }\n      const {\n        children\n      } = self;\n      if (options.showAllItemsBeforeCalculate) {\n        for (const child of children) {\n          if (child.hasAttribute(hiddenAttr)) {\n            child.removeAttribute(hiddenAttr);\n          }\n        }\n      }\n      const containerWidth = self.offsetWidth;\n      const childWidths = [];\n      const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;\n      let childWidthSum = tail ? tail.offsetWidth : 0;\n      let overflow = false;\n      const len = self.children.length - (slots.tail ? 1 : 0);\n      for (let i = 0; i < len - 1; ++i) {\n        if (i < 0) continue;\n        const child = children[i];\n        if (overflow) {\n          if (!child.hasAttribute(hiddenAttr)) {\n            child.setAttribute(hiddenAttr, '');\n          }\n          continue;\n        } else if (child.hasAttribute(hiddenAttr)) {\n          child.removeAttribute(hiddenAttr);\n        }\n        const childWidth = child.offsetWidth;\n        childWidthSum += childWidth;\n        childWidths[i] = childWidth;\n        if (childWidthSum > containerWidth) {\n          const {\n            updateCounter\n          } = props;\n          for (let j = i; j >= 0; --j) {\n            const restCount = len - 1 - j;\n            if (updateCounter !== undefined) {\n              updateCounter(restCount);\n            } else {\n              counter.textContent = `${restCount}`;\n            }\n            const counterWidth = counter.offsetWidth;\n            childWidthSum -= childWidths[j];\n            if (childWidthSum + counterWidth <= containerWidth || j === 0) {\n              overflow = true;\n              i = j - 1;\n              if (tail) {\n                // tail too long or 1st element too long\n                // we only consider tail now\n                if (i === -1) {\n                  tail.style.maxWidth = `${containerWidth - counterWidth}px`;\n                  tail.style.boxSizing = 'border-box';\n                } else {\n                  tail.style.maxWidth = '';\n                }\n              }\n              const {\n                onUpdateCount\n              } = props;\n              if (onUpdateCount) onUpdateCount(restCount);\n              break;\n            }\n          }\n        }\n      }\n      const {\n        onUpdateOverflow\n      } = props;\n      if (!overflow) {\n        if (onUpdateOverflow !== undefined) {\n          onUpdateOverflow(false);\n        }\n        counter.setAttribute(hiddenAttr, '');\n      } else {\n        if (onUpdateOverflow !== undefined) {\n          onUpdateOverflow(true);\n        }\n      }\n    }\n    const ssrAdapter = useSsrAdapter();\n    style.mount({\n      id: 'vueuc/overflow',\n      head: true,\n      anchorMetaName: cssrAnchorMetaName,\n      ssr: ssrAdapter\n    });\n    onMounted(() => deriveCounter({\n      showAllItemsBeforeCalculate: false\n    }));\n    // besides onMounted, other case should be manually triggered, or we shoud watch items\n    return {\n      selfRef,\n      counterRef,\n      sync: deriveCounter\n    };\n  },\n  render() {\n    const {\n      $slots\n    } = this;\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => this.sync({\n      showAllItemsBeforeCalculate: false\n    }));\n    // It shouldn't have border\n    return h('div', {\n      class: 'v-overflow',\n      ref: 'selfRef'\n    }, [renderSlot($slots, 'default'),\n    // $slots.counter should only has 1 element\n    $slots.counter ? $slots.counter() : h('span', {\n      style: {\n        display: 'inline-block'\n      },\n      ref: 'counterRef'\n    }),\n    // $slots.tail should only has 1 element\n    $slots.tail ? $slots.tail() : null]);\n  }\n});","map":{"version":3,"names":["defineComponent","renderSlot","h","onMounted","ref","nextTick","useSsrAdapter","c","cssrAnchorMetaName","hiddenAttr","style","display","name","props","getCounter","Function","getTail","updateCounter","onUpdateCount","onUpdateOverflow","setup","slots","selfRef","counterRef","deriveCounter","options","value","self","counter","undefined","hasAttribute","removeAttribute","children","showAllItemsBeforeCalculate","child","containerWidth","offsetWidth","childWidths","tail","childWidthSum","overflow","len","length","i","setAttribute","childWidth","j","restCount","textContent","counterWidth","maxWidth","boxSizing","ssrAdapter","mount","id","head","anchorMetaName","ssr","sync","render","$slots","class"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/vueuc/es/overflow/src/index.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { defineComponent, renderSlot, h, onMounted, ref, nextTick } from 'vue';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nconst hiddenAttr = 'v-hidden';\nconst style = c('[v-hidden]', {\n    display: 'none!important'\n});\nexport default defineComponent({\n    name: 'Overflow',\n    props: {\n        getCounter: Function,\n        getTail: Function,\n        updateCounter: Function,\n        onUpdateCount: Function,\n        onUpdateOverflow: Function\n    },\n    setup(props, { slots }) {\n        const selfRef = ref(null);\n        const counterRef = ref(null);\n        function deriveCounter(options) {\n            const { value: self } = selfRef;\n            const { getCounter, getTail } = props;\n            let counter;\n            if (getCounter !== undefined)\n                counter = getCounter();\n            else {\n                counter = counterRef.value;\n            }\n            if (!self || !counter)\n                return;\n            if (counter.hasAttribute(hiddenAttr)) {\n                counter.removeAttribute(hiddenAttr);\n            }\n            const { children } = self;\n            if (options.showAllItemsBeforeCalculate) {\n                for (const child of children) {\n                    if (child.hasAttribute(hiddenAttr)) {\n                        child.removeAttribute(hiddenAttr);\n                    }\n                }\n            }\n            const containerWidth = self.offsetWidth;\n            const childWidths = [];\n            const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;\n            let childWidthSum = tail ? tail.offsetWidth : 0;\n            let overflow = false;\n            const len = self.children.length - (slots.tail ? 1 : 0);\n            for (let i = 0; i < len - 1; ++i) {\n                if (i < 0)\n                    continue;\n                const child = children[i];\n                if (overflow) {\n                    if (!child.hasAttribute(hiddenAttr)) {\n                        child.setAttribute(hiddenAttr, '');\n                    }\n                    continue;\n                }\n                else if (child.hasAttribute(hiddenAttr)) {\n                    child.removeAttribute(hiddenAttr);\n                }\n                const childWidth = child.offsetWidth;\n                childWidthSum += childWidth;\n                childWidths[i] = childWidth;\n                if (childWidthSum > containerWidth) {\n                    const { updateCounter } = props;\n                    for (let j = i; j >= 0; --j) {\n                        const restCount = len - 1 - j;\n                        if (updateCounter !== undefined) {\n                            updateCounter(restCount);\n                        }\n                        else {\n                            counter.textContent = `${restCount}`;\n                        }\n                        const counterWidth = counter.offsetWidth;\n                        childWidthSum -= childWidths[j];\n                        if (childWidthSum + counterWidth <= containerWidth || j === 0) {\n                            overflow = true;\n                            i = j - 1;\n                            if (tail) {\n                                // tail too long or 1st element too long\n                                // we only consider tail now\n                                if (i === -1) {\n                                    tail.style.maxWidth = `${containerWidth - counterWidth}px`;\n                                    tail.style.boxSizing = 'border-box';\n                                }\n                                else {\n                                    tail.style.maxWidth = '';\n                                }\n                            }\n                            const { onUpdateCount } = props;\n                            if (onUpdateCount)\n                                onUpdateCount(restCount);\n                            break;\n                        }\n                    }\n                }\n            }\n            const { onUpdateOverflow } = props;\n            if (!overflow) {\n                if (onUpdateOverflow !== undefined) {\n                    onUpdateOverflow(false);\n                }\n                counter.setAttribute(hiddenAttr, '');\n            }\n            else {\n                if (onUpdateOverflow !== undefined) {\n                    onUpdateOverflow(true);\n                }\n            }\n        }\n        const ssrAdapter = useSsrAdapter();\n        style.mount({\n            id: 'vueuc/overflow',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onMounted(() => deriveCounter({\n            showAllItemsBeforeCalculate: false\n        }));\n        // besides onMounted, other case should be manually triggered, or we shoud watch items\n        return {\n            selfRef,\n            counterRef,\n            sync: deriveCounter\n        };\n    },\n    render() {\n        const { $slots } = this;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nextTick(() => this.sync({\n            showAllItemsBeforeCalculate: false\n        }));\n        // It shouldn't have border\n        return h('div', {\n            class: 'v-overflow',\n            ref: 'selfRef'\n        }, [\n            renderSlot($slots, 'default'),\n            // $slots.counter should only has 1 element\n            $slots.counter\n                ? $slots.counter()\n                : h('span', {\n                    style: {\n                        display: 'inline-block'\n                    },\n                    ref: 'counterRef'\n                }),\n            // $slots.tail should only has 1 element\n            $slots.tail ? $slots.tail() : null\n        ]);\n    }\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}