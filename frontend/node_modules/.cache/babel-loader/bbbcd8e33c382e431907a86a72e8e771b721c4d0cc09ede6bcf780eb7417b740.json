{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\nimport { h, defineComponent, ref, cloneVNode, computed, onBeforeUnmount, watch, withDirectives, vShow, Transition, toRef, nextTick, onMounted, watchEffect, normalizeStyle, onUpdated } from 'vue';\nimport { VResizeObserver } from 'vueuc';\nimport { useMergedState } from 'vooks';\nimport { on, off } from 'evtd';\nimport { getPreciseEventTarget } from 'seemly';\nimport { useConfig, useTheme, useThemeClass } from \"../../_mixins/index.mjs\";\nimport { flatten, keep, resolveSlotWithProps } from \"../../_utils/index.mjs\";\nimport { carouselLight } from \"../styles/index.mjs\";\nimport { calculateSize, clampValue, resolveSpeed, isTouchEvent, getNextIndex, getPrevIndex, getDisplayIndex, getRealIndex, getDisplayTotalView, addDuplicateSlides } from \"./utils/index.mjs\";\nimport { provideCarouselContext } from \"./CarouselContext.mjs\";\nimport NCarouselDots from \"./CarouselDots.mjs\";\nimport NCarouselArrow from \"./CarouselArrow.mjs\";\nimport NCarouselItem, { isCarouselItem } from \"./CarouselItem.mjs\";\nimport style from \"./styles/index.cssr.mjs\";\nconst transitionProperties = ['transitionDuration', 'transitionTimingFunction'];\nexport const carouselProps = Object.assign(Object.assign({}, useTheme.props), {\n  defaultIndex: {\n    type: Number,\n    default: 0\n  },\n  currentIndex: Number,\n  showArrow: Boolean,\n  dotType: {\n    type: String,\n    default: 'dot'\n  },\n  dotPlacement: {\n    type: String,\n    default: 'bottom'\n  },\n  slidesPerView: {\n    type: [Number, String],\n    default: 1\n  },\n  spaceBetween: {\n    type: Number,\n    default: 0\n  },\n  centeredSlides: Boolean,\n  direction: {\n    type: String,\n    default: 'horizontal'\n  },\n  autoplay: Boolean,\n  interval: {\n    type: Number,\n    default: 5000\n  },\n  loop: {\n    type: Boolean,\n    default: true\n  },\n  effect: {\n    type: String,\n    default: 'slide'\n  },\n  showDots: {\n    type: Boolean,\n    default: true\n  },\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  transitionStyle: {\n    type: Object,\n    default: () => ({\n      transitionDuration: '300ms'\n    })\n  },\n  transitionProps: Object,\n  draggable: Boolean,\n  prevSlideStyle: [Object, String],\n  nextSlideStyle: [Object, String],\n  touchable: {\n    type: Boolean,\n    default: true\n  },\n  mousewheel: Boolean,\n  keyboard: Boolean,\n  'onUpdate:currentIndex': Function,\n  onUpdateCurrentIndex: Function\n});\n// only one carousel is allowed to trigger touch globally\nlet globalDragging = false;\nexport default defineComponent({\n  name: 'Carousel',\n  props: carouselProps,\n  setup(props) {\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    // Dom\n    const selfElRef = ref(null);\n    const slidesElRef = ref(null);\n    const slideElsRef = ref([]);\n    const slideVNodesRef = {\n      value: []\n    };\n    // Computed states\n    const verticalRef = computed(() => props.direction === 'vertical');\n    const sizeAxisRef = computed(() => verticalRef.value ? 'height' : 'width');\n    const spaceAxisRef = computed(() => verticalRef.value ? 'bottom' : 'right');\n    const sequenceLayoutRef = computed(() => props.effect === 'slide');\n    const duplicatedableRef = computed(\n    // duplicate the copy operation in `slide` mode,\n    // because only its DOM is sequence layout\n    () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value);\n    // user wants to control the transition animation\n    const userWantsControlRef = computed(() => props.effect === 'custom');\n    // used to calculate total views\n    const displaySlidesPerViewRef = computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView);\n    // used to calculate the size of each slide\n    const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);\n    // we automatically calculate total view for special slides per view\n    const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' || props.slidesPerView === 'auto' && props.centeredSlides);\n    // Carousel size\n    const perViewSizeRef = ref({\n      width: 0,\n      height: 0\n    });\n    const slideSizesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      if (!slidesEls.length) return [];\n      const {\n        value: autoSlideSize\n      } = autoSlideSizeRef;\n      if (autoSlideSize) {\n        return slidesEls.map(slide => calculateSize(slide));\n      }\n      const {\n        value: slidesPerView\n      } = realSlidesPerViewRef;\n      const {\n        value: perViewSize\n      } = perViewSizeRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      let axisSize = perViewSize[axis];\n      if (slidesPerView !== 'auto') {\n        const {\n          spaceBetween\n        } = props;\n        const remaining = axisSize - (slidesPerView - 1) * spaceBetween;\n        const percentage = 1 / Math.max(1, slidesPerView);\n        axisSize = remaining * percentage;\n      }\n      const slideSize = Object.assign(Object.assign({}, perViewSize), {\n        [axis]: axisSize\n      });\n      return slidesEls.map(() => slideSize);\n    });\n    // The translate required to reach each slide\n    const slideTranlatesRef = computed(() => {\n      const {\n        value: slideSizes\n      } = slideSizesRef;\n      if (!slideSizes.length) return [];\n      const {\n        centeredSlides,\n        spaceBetween\n      } = props;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const {\n        [axis]: perViewSize\n      } = perViewSizeRef.value;\n      let previousTranslate = 0;\n      return slideSizes.map(({\n        [axis]: slideSize\n      }) => {\n        let translate = previousTranslate;\n        if (centeredSlides) {\n          translate += (slideSize - perViewSize) / 2;\n        }\n        previousTranslate += slideSize + spaceBetween;\n        return translate;\n      });\n    });\n    // Styles\n    const isMountedRef = ref(false);\n    const transitionStyleRef = computed(() => {\n      const {\n        transitionStyle\n      } = props;\n      return transitionStyle ? keep(transitionStyle, transitionProperties) : {};\n    });\n    const speedRef = computed(() => userWantsControlRef.value ? 0 : resolveSpeed(transitionStyleRef.value.transitionDuration));\n    const slideStylesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      if (!slidesEls.length) return [];\n      const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);\n      const getSlideSize = index => {\n        if (useComputedSize) {\n          const {\n            value: axis\n          } = sizeAxisRef;\n          return {\n            [axis]: `${slideSizesRef.value[index][axis]}px`\n          };\n        }\n      };\n      if (userWantsControlRef.value) {\n        // We center each slide when user wants to control the transition animation,\n        // so there is no need to calculate the offset\n        return slidesEls.map((_, i) => getSlideSize(i));\n      }\n      const {\n        effect,\n        spaceBetween\n      } = props;\n      const {\n        value: spaceAxis\n      } = spaceAxisRef;\n      return slidesEls.reduce((styles, _, i) => {\n        const style = Object.assign(Object.assign({}, getSlideSize(i)), {\n          [`margin-${spaceAxis}`]: `${spaceBetween}px`\n        });\n        styles.push(style);\n        if (isMountedRef.value && (effect === 'fade' || effect === 'card')) {\n          Object.assign(style, transitionStyleRef.value);\n        }\n        return styles;\n      }, []);\n    });\n    // Total\n    const totalViewRef = computed(() => {\n      const {\n        value: slidesPerView\n      } = displaySlidesPerViewRef;\n      const {\n        length: totalSlides\n      } = slideElsRef.value;\n      if (slidesPerView !== 'auto') {\n        return Math.max(totalSlides - slidesPerView, 0) + 1;\n      } else {\n        const {\n          value: slideSizes\n        } = slideSizesRef;\n        const {\n          length\n        } = slideSizes;\n        if (!length) return totalSlides;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis];\n        let lastViewSize = slideSizes[slideSizes.length - 1][axis];\n        let i = length;\n        while (i > 1 && lastViewSize < perViewSize) {\n          i--;\n          lastViewSize += translates[i] - translates[i - 1];\n        }\n        return clampValue(i + 1, 1, length);\n      }\n    });\n    const displayTotalViewRef = computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value));\n    // Index\n    const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);\n    const uncontrolledDisplayIndexRef = ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));\n    const mergedDisplayIndexRef = useMergedState(toRef(props, 'currentIndex'), uncontrolledDisplayIndexRef);\n    const realIndexRef = computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value));\n    // Reality methods\n    function toRealIndex(index) {\n      var _a, _b;\n      index = clampValue(index, 0, totalViewRef.value - 1);\n      const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);\n      const {\n        value: lastDisplayIndex\n      } = mergedDisplayIndexRef;\n      if (displayIndex !== mergedDisplayIndexRef.value) {\n        uncontrolledDisplayIndexRef.value = displayIndex;\n        (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);\n        (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);\n      }\n    }\n    function getRealPrevIndex(index = realIndexRef.value) {\n      return getPrevIndex(index, totalViewRef.value, props.loop);\n    }\n    function getRealNextIndex(index = realIndexRef.value) {\n      return getNextIndex(index, totalViewRef.value, props.loop);\n    }\n    function isRealPrev(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealPrevIndex() === index;\n    }\n    function isRealNext(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealNextIndex() === index;\n    }\n    function isRealActive(slideOrIndex) {\n      return realIndexRef.value === getSlideIndex(slideOrIndex);\n    }\n    // Display methods\n    // They are used to deal with the actual values displayed on the UI\n    function isDisplayActive(index) {\n      return mergedDisplayIndexRef.value === index;\n    }\n    function isPrevDisabled() {\n      return getRealPrevIndex() === null;\n    }\n    function isNextDisabled() {\n      return getRealNextIndex() === null;\n    }\n    // To\n    function to(index) {\n      const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);\n      if (index !== mergedDisplayIndexRef.value || realIndex !== realIndexRef.value) {\n        toRealIndex(realIndex);\n      }\n    }\n    function prev() {\n      const prevIndex = getRealPrevIndex();\n      if (prevIndex !== null) toRealIndex(prevIndex);\n    }\n    function next() {\n      const nextIndex = getRealNextIndex();\n      if (nextIndex !== null) toRealIndex(nextIndex);\n    }\n    function prevIfSlideTransitionEnd() {\n      if (!inTransition || !duplicatedableRef.value) prev();\n    }\n    function nextIfSlideTransitionEnd() {\n      if (!inTransition || !duplicatedableRef.value) next();\n    }\n    // Translate to\n    let inTransition = false;\n    // record the translate of each slide, so that it can be restored at touch\n    let previousTranslate = 0;\n    const translateStyleRef = ref({});\n    function updateTranslate(translate, speed = 0) {\n      translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {\n        transform: verticalRef.value ? `translateY(${-translate}px)` : `translateX(${-translate}px)`,\n        transitionDuration: `${speed}ms`\n      });\n    }\n    function fixTranslate(speed = 0) {\n      if (sequenceLayoutRef.value) {\n        translateTo(realIndexRef.value, speed);\n      } else if (previousTranslate !== 0) {\n        if (!inTransition && speed > 0) {\n          inTransition = true;\n        }\n        updateTranslate(previousTranslate = 0, speed);\n      }\n    }\n    function translateTo(index, speed) {\n      const translate = getTranslate(index);\n      if (translate !== previousTranslate && speed > 0) {\n        inTransition = true;\n      }\n      previousTranslate = getTranslate(realIndexRef.value);\n      updateTranslate(translate, speed);\n    }\n    function getTranslate(index) {\n      let translate;\n      // Deal with auto slides pre view\n      if (index >= totalViewRef.value - 1) {\n        translate = getLastViewTranslate();\n      } else {\n        translate = slideTranlatesRef.value[index] || 0;\n      }\n      return translate;\n    }\n    function getLastViewTranslate() {\n      if (displaySlidesPerViewRef.value === 'auto') {\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const {\n          [axis]: perViewSize\n        } = perViewSizeRef.value;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const lastTranslate = translates[translates.length - 1];\n        let overallSize;\n        if (lastTranslate === undefined) {\n          overallSize = perViewSize;\n        } else {\n          const {\n            value: slideSizes\n          } = slideSizesRef;\n          overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];\n        }\n        // Bring the last slide to the edge\n        return overallSize - perViewSize;\n      } else {\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        return translates[totalViewRef.value - 1] || 0;\n      }\n    }\n    // Provide\n    const carouselContext = {\n      currentIndexRef: mergedDisplayIndexRef,\n      to,\n      prev: prevIfSlideTransitionEnd,\n      next: nextIfSlideTransitionEnd,\n      isVertical: () => verticalRef.value,\n      isHorizontal: () => !verticalRef.value,\n      isPrev: isRealPrev,\n      isNext: isRealNext,\n      isActive: isRealActive,\n      isPrevDisabled,\n      isNextDisabled,\n      getSlideIndex,\n      getSlideStyle,\n      addSlide,\n      removeSlide,\n      onCarouselItemClick\n    };\n    provideCarouselContext(carouselContext);\n    function addSlide(slide) {\n      if (!slide) return;\n      slideElsRef.value.push(slide);\n    }\n    function removeSlide(slide) {\n      if (!slide) return;\n      const index = getSlideIndex(slide);\n      if (index !== -1) {\n        slideElsRef.value.splice(index, 1);\n      }\n    }\n    function getSlideIndex(slideOrIndex) {\n      return typeof slideOrIndex === 'number' ? slideOrIndex : slideOrIndex ? slideElsRef.value.indexOf(slideOrIndex) : -1;\n    }\n    function getSlideStyle(slide) {\n      const index = getSlideIndex(slide);\n      if (index !== -1) {\n        const styles = [slideStylesRef.value[index]];\n        const isPrev = carouselContext.isPrev(index);\n        const isNext = carouselContext.isNext(index);\n        if (isPrev) {\n          styles.push(props.prevSlideStyle || '');\n        }\n        if (isNext) {\n          styles.push(props.nextSlideStyle || '');\n        }\n        return normalizeStyle(styles);\n      }\n    }\n    function onCarouselItemClick(index, event) {\n      let allowClick = !inTransition && !dragging && !isEffectiveDrag;\n      if (props.effect === 'card' && allowClick && !isRealActive(index)) {\n        to(index);\n        allowClick = false;\n      }\n      if (!allowClick) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n    // Autoplay\n    let autoplayTimer = null;\n    function stopAutoplay() {\n      if (autoplayTimer) {\n        clearInterval(autoplayTimer);\n        autoplayTimer = null;\n      }\n    }\n    function resetAutoplay() {\n      stopAutoplay();\n      const disabled = !props.autoplay || displayTotalViewRef.value < 2;\n      if (!disabled) {\n        autoplayTimer = window.setInterval(next, props.interval);\n      }\n    }\n    // Drag\n    let dragStartX = 0;\n    let dragStartY = 0;\n    let dragOffset = 0;\n    let dragStartTime = 0;\n    let dragging = false;\n    let isEffectiveDrag = false;\n    function handleTouchstart(event) {\n      var _a;\n      if (globalDragging) return;\n      if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {\n        return;\n      }\n      globalDragging = true;\n      dragging = true;\n      isEffectiveDrag = false;\n      dragStartTime = Date.now();\n      stopAutoplay();\n      if (event.type !== 'touchstart' && !event.target.isContentEditable) {\n        event.preventDefault();\n      }\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n      if (verticalRef.value) {\n        dragStartY = touchEvent.clientY;\n      } else {\n        dragStartX = touchEvent.clientX;\n      }\n      if (props.touchable) {\n        on('touchmove', document, handleTouchmove);\n        on('touchend', document, handleTouchend);\n        on('touchcancel', document, handleTouchend);\n      }\n      if (props.draggable) {\n        on('mousemove', document, handleTouchmove);\n        on('mouseup', document, handleTouchend);\n      }\n    }\n    function handleTouchmove(event) {\n      const {\n        value: vertical\n      } = verticalRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n      const offset = vertical ? touchEvent.clientY - dragStartY : touchEvent.clientX - dragStartX;\n      const perViewSize = perViewSizeRef.value[axis];\n      dragOffset = clampValue(offset, -perViewSize, perViewSize);\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if (sequenceLayoutRef.value) {\n        updateTranslate(previousTranslate - dragOffset, 0);\n      }\n    }\n    function handleTouchend() {\n      const {\n        value: realIndex\n      } = realIndexRef;\n      let currentIndex = realIndex;\n      if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {\n        const currentTranslate = previousTranslate - dragOffset;\n        const translates = [...slideTranlatesRef.value.slice(0, totalViewRef.value - 1), getLastViewTranslate()];\n        let prevOffset = null;\n        for (let i = 0; i < translates.length; i++) {\n          const offset = Math.abs(translates[i] - currentTranslate);\n          if (prevOffset !== null && prevOffset < offset) {\n            break;\n          }\n          prevOffset = offset;\n          currentIndex = i;\n        }\n      }\n      if (currentIndex === realIndex) {\n        const timeElapsed = Date.now() - dragStartTime;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis];\n        // more than 50% width or faster than 0.4px per ms\n        if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {\n          currentIndex = getRealPrevIndex(realIndex);\n        } else if (dragOffset < -perViewSize / 2 || dragOffset / timeElapsed < -0.4) {\n          currentIndex = getRealNextIndex(realIndex);\n        }\n      }\n      if (currentIndex !== null && currentIndex !== realIndex) {\n        isEffectiveDrag = true;\n        toRealIndex(currentIndex);\n        void nextTick(() => {\n          if (!duplicatedableRef.value || uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {\n            fixTranslate(speedRef.value);\n          }\n        });\n      } else {\n        fixTranslate(speedRef.value);\n      }\n      resetDragStatus();\n      resetAutoplay();\n    }\n    function resetDragStatus() {\n      if (dragging) {\n        globalDragging = false;\n      }\n      dragging = false;\n      dragStartX = 0;\n      dragStartY = 0;\n      dragOffset = 0;\n      dragStartTime = 0;\n      off('touchmove', document, handleTouchmove);\n      off('touchend', document, handleTouchend);\n      off('touchcancel', document, handleTouchend);\n      off('mousemove', document, handleTouchmove);\n      off('mouseup', document, handleTouchend);\n    }\n    function handleTransitionEnd() {\n      if (sequenceLayoutRef.value && inTransition) {\n        const {\n          value: realIndex\n        } = realIndexRef;\n        translateTo(realIndex, 0);\n      } else {\n        resetAutoplay();\n      }\n      if (sequenceLayoutRef.value) {\n        translateStyleRef.value.transitionDuration = '0ms';\n      }\n      inTransition = false;\n    }\n    function handleMousewheel(event) {\n      event.preventDefault();\n      if (inTransition) return;\n      let {\n        deltaX,\n        deltaY\n      } = event;\n      if (event.shiftKey && !deltaX) {\n        deltaX = deltaY;\n      }\n      const prevMultiplier = -1;\n      const nextMultiplier = 1;\n      const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;\n      let rx = 0;\n      let ry = 0;\n      if (verticalRef.value) {\n        ry = m;\n      } else {\n        rx = m;\n      }\n      const responseStep = 10;\n      if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {\n        if (m === nextMultiplier && !isNextDisabled()) {\n          next();\n        } else if (m === prevMultiplier && !isPrevDisabled()) {\n          prev();\n        }\n      }\n    }\n    function handleResize() {\n      perViewSizeRef.value = calculateSize(selfElRef.value, true);\n      resetAutoplay();\n    }\n    function handleSlideResize() {\n      var _a, _b;\n      if (autoSlideSizeRef.value) {\n        (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);\n        slideSizesRef.effect.run();\n      }\n    }\n    function handleMouseenter() {\n      if (props.autoplay) {\n        stopAutoplay();\n      }\n    }\n    function handleMouseleave() {\n      if (props.autoplay) {\n        resetAutoplay();\n      }\n    }\n    onMounted(() => {\n      watchEffect(resetAutoplay);\n      requestAnimationFrame(() => isMountedRef.value = true);\n    });\n    onBeforeUnmount(() => {\n      resetDragStatus();\n      stopAutoplay();\n    });\n    // Fix index when remounting\n    onUpdated(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      const {\n        value: slideVNodes\n      } = slideVNodesRef;\n      const indexMap = new Map();\n      const getDisplayIndex = el =>\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      indexMap.has(el) ? indexMap.get(el) : -1;\n      let isChanged = false;\n      for (let i = 0; i < slidesEls.length; i++) {\n        const index = slideVNodes.findIndex(v => v.el === slidesEls[i]);\n        if (index !== i) {\n          isChanged = true;\n        }\n        indexMap.set(slidesEls[i], index);\n      }\n      if (isChanged) {\n        slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));\n      }\n    });\n    watch(realIndexRef, (realIndex, lastRealIndex) => {\n      if (realIndex === lastRealIndex) return;\n      resetAutoplay();\n      if (sequenceLayoutRef.value) {\n        if (duplicatedableRef.value) {\n          const {\n            value: length\n          } = totalViewRef;\n          if (displayTotalViewRef.value > 2 && realIndex === length - 2 && lastRealIndex === 1) {\n            realIndex = 0;\n          } else if (realIndex === 1 && lastRealIndex === length - 2) {\n            realIndex = length - 1;\n          }\n        }\n        translateTo(realIndex, speedRef.value);\n      } else {\n        fixTranslate();\n      }\n    }, {\n      immediate: true\n    });\n    watch([duplicatedableRef, displaySlidesPerViewRef], () => void nextTick(() => {\n      toRealIndex(realIndexRef.value);\n    }));\n    watch(slideTranlatesRef, () => {\n      sequenceLayoutRef.value && fixTranslate();\n    }, {\n      deep: true\n    });\n    watch(sequenceLayoutRef, value => {\n      if (!value) {\n        inTransition = false;\n        // if the current mode does not support translate, reset the position of the wrapper\n        updateTranslate(previousTranslate = 0);\n      } else {\n        fixTranslate();\n      }\n    });\n    const slidesControlListenersRef = computed(() => {\n      return {\n        onTouchstartPassive: props.touchable ? handleTouchstart : undefined,\n        onMousedown: props.draggable ? handleTouchstart : undefined,\n        onWheel: props.mousewheel ? handleMousewheel : undefined\n      };\n    });\n    const arrowSlotPropsRef = computed(() => Object.assign(Object.assign({}, keep(carouselContext, ['to', 'prev', 'next', 'isPrevDisabled', 'isNextDisabled'])), {\n      total: displayTotalViewRef.value,\n      currentIndex: mergedDisplayIndexRef.value\n    }));\n    const dotSlotPropsRef = computed(() => ({\n      total: displayTotalViewRef.value,\n      currentIndex: mergedDisplayIndexRef.value,\n      to: carouselContext.to\n    }));\n    const caroulseExposedMethod = {\n      getCurrentIndex: () => mergedDisplayIndexRef.value,\n      to,\n      prev,\n      next\n    };\n    const themeRef = useTheme('Carousel', '-carousel', style, carouselLight, props, mergedClsPrefixRef);\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          dotSize,\n          dotColor,\n          dotColorActive,\n          dotColorFocus,\n          dotLineWidth,\n          dotLineWidthActive,\n          arrowColor\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-dot-color': dotColor,\n        '--n-dot-color-focus': dotColorFocus,\n        '--n-dot-color-active': dotColorActive,\n        '--n-dot-size': dotSize,\n        '--n-dot-line-width': dotLineWidth,\n        '--n-dot-line-width-active': dotLineWidthActive,\n        '--n-arrow-color': arrowColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('carousel', undefined, cssVarsRef, props) : undefined;\n    return Object.assign(Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      selfElRef,\n      slidesElRef,\n      slideVNodes: slideVNodesRef,\n      duplicatedable: duplicatedableRef,\n      userWantsControl: userWantsControlRef,\n      autoSlideSize: autoSlideSizeRef,\n      realIndex: realIndexRef,\n      slideStyles: slideStylesRef,\n      translateStyle: translateStyleRef,\n      slidesControlListeners: slidesControlListenersRef,\n      handleTransitionEnd,\n      handleResize,\n      handleSlideResize,\n      handleMouseenter,\n      handleMouseleave,\n      isActive: isDisplayActive,\n      arrowSlotProps: arrowSlotPropsRef,\n      dotSlotProps: dotSlotPropsRef\n    }, caroulseExposedMethod), {\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n  render() {\n    var _a;\n    const {\n      mergedClsPrefix,\n      showArrow,\n      userWantsControl,\n      slideStyles,\n      dotType,\n      dotPlacement,\n      slidesControlListeners,\n      transitionProps = {},\n      arrowSlotProps,\n      dotSlotProps,\n      $slots: {\n        default: defaultSlot,\n        dots: dotsSlot,\n        arrow: arrowSlot\n      }\n    } = this;\n    const children = defaultSlot && flatten(defaultSlot()) || [];\n    let slides = filterCarouselItem(children);\n    if (!slides.length) {\n      slides = children.map(ch => h(NCarouselItem, null, {\n        default: () => cloneVNode(ch)\n      }));\n    }\n    if (this.duplicatedable) {\n      slides = addDuplicateSlides(slides);\n    }\n    this.slideVNodes.value = slides;\n    // When users need to customize the size of the slide,\n    // we listen to them to fix the current translate\n    if (this.autoSlideSize) {\n      slides = slides.map(slide => h(VResizeObserver, {\n        onResize: this.handleSlideResize\n      }, {\n        default: () => slide\n      }));\n    }\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    return h(\"div\", Object.assign({\n      ref: \"selfElRef\",\n      class: [this.themeClass, `${mergedClsPrefix}-carousel`, this.direction === 'vertical' && `${mergedClsPrefix}-carousel--vertical`, this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`, `${mergedClsPrefix}-carousel--${dotPlacement}`, `${mergedClsPrefix}-carousel--${this.direction}`, `${mergedClsPrefix}-carousel--${this.effect}`, userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`],\n      style: this.cssVars\n    }, slidesControlListeners, {\n      onMouseenter: this.handleMouseenter,\n      onMouseleave: this.handleMouseleave\n    }), h(VResizeObserver, {\n      onResize: this.handleResize\n    }, {\n      default: () => h(\"div\", {\n        ref: \"slidesElRef\",\n        class: `${mergedClsPrefix}-carousel__slides`,\n        role: \"listbox\",\n        style: this.translateStyle,\n        onTransitionend: this.handleTransitionEnd\n      }, userWantsControl ? slides.map((slide, i) => h(\"div\", {\n        style: slideStyles[i],\n        key: i\n      }, withDirectives(h(Transition, Object.assign({}, transitionProps), {\n        default: () => slide\n      }), [[vShow, this.isActive(i)]]))) : slides)\n    }), this.showDots && dotSlotProps.total > 1 && resolveSlotWithProps(dotsSlot, dotSlotProps, () => [h(NCarouselDots, {\n      key: dotType + dotPlacement,\n      total: dotSlotProps.total,\n      currentIndex: dotSlotProps.currentIndex,\n      dotType: dotType,\n      trigger: this.trigger,\n      keyboard: this.keyboard\n    })]), showArrow && resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [h(NCarouselArrow, null)]));\n  }\n});\nfunction filterCarouselItem(vnodes) {\n  return vnodes.reduce((carouselItems, vnode) => {\n    if (isCarouselItem(vnode)) {\n      carouselItems.push(vnode);\n    }\n    return carouselItems;\n  }, []);\n}","map":{"version":3,"names":["h","defineComponent","ref","cloneVNode","computed","onBeforeUnmount","watch","withDirectives","vShow","Transition","toRef","nextTick","onMounted","watchEffect","normalizeStyle","onUpdated","VResizeObserver","useMergedState","on","off","getPreciseEventTarget","useConfig","useTheme","useThemeClass","flatten","keep","resolveSlotWithProps","carouselLight","calculateSize","clampValue","resolveSpeed","isTouchEvent","getNextIndex","getPrevIndex","getDisplayIndex","getRealIndex","getDisplayTotalView","addDuplicateSlides","provideCarouselContext","NCarouselDots","NCarouselArrow","NCarouselItem","isCarouselItem","style","transitionProperties","carouselProps","Object","assign","props","defaultIndex","type","Number","default","currentIndex","showArrow","Boolean","dotType","String","dotPlacement","slidesPerView","spaceBetween","centeredSlides","direction","autoplay","interval","loop","effect","showDots","trigger","transitionStyle","transitionDuration","transitionProps","draggable","prevSlideStyle","nextSlideStyle","touchable","mousewheel","keyboard","Function","onUpdateCurrentIndex","globalDragging","name","setup","mergedClsPrefixRef","inlineThemeDisabled","selfElRef","slidesElRef","slideElsRef","slideVNodesRef","value","verticalRef","sizeAxisRef","spaceAxisRef","sequenceLayoutRef","duplicatedableRef","userWantsControlRef","displaySlidesPerViewRef","realSlidesPerViewRef","autoSlideSizeRef","perViewSizeRef","width","height","slideSizesRef","slidesEls","length","autoSlideSize","map","slide","perViewSize","axis","axisSize","remaining","percentage","Math","max","slideSize","slideTranlatesRef","slideSizes","previousTranslate","translate","isMountedRef","transitionStyleRef","speedRef","slideStylesRef","useComputedSize","getSlideSize","index","_","i","spaceAxis","reduce","styles","push","totalViewRef","totalSlides","translates","lastViewSize","displayTotalViewRef","defaultRealIndex","uncontrolledDisplayIndexRef","mergedDisplayIndexRef","realIndexRef","toRealIndex","_a","_b","displayIndex","lastDisplayIndex","call","getRealPrevIndex","getRealNextIndex","isRealPrev","slideOrIndex","getSlideIndex","isRealNext","isRealActive","isDisplayActive","isPrevDisabled","isNextDisabled","to","realIndex","prev","prevIndex","next","nextIndex","prevIfSlideTransitionEnd","inTransition","nextIfSlideTransitionEnd","translateStyleRef","updateTranslate","speed","transform","fixTranslate","translateTo","getTranslate","getLastViewTranslate","lastTranslate","overallSize","undefined","carouselContext","currentIndexRef","isVertical","isHorizontal","isPrev","isNext","isActive","getSlideStyle","addSlide","removeSlide","onCarouselItemClick","splice","indexOf","event","allowClick","dragging","isEffectiveDrag","preventDefault","stopPropagation","autoplayTimer","stopAutoplay","clearInterval","resetAutoplay","disabled","window","setInterval","dragStartX","dragStartY","dragOffset","dragStartTime","handleTouchstart","contains","Date","now","target","isContentEditable","touchEvent","touches","clientY","clientX","document","handleTouchmove","handleTouchend","vertical","offset","cancelable","currentTranslate","slice","prevOffset","abs","timeElapsed","resetDragStatus","handleTransitionEnd","handleMousewheel","deltaX","deltaY","shiftKey","prevMultiplier","nextMultiplier","m","rx","ry","responseStep","handleResize","handleSlideResize","scheduler","run","handleMouseenter","handleMouseleave","requestAnimationFrame","slideVNodes","indexMap","Map","el","has","get","isChanged","findIndex","v","set","sort","a","b","lastRealIndex","immediate","deep","slidesControlListenersRef","onTouchstartPassive","onMousedown","onWheel","arrowSlotPropsRef","total","dotSlotPropsRef","caroulseExposedMethod","getCurrentIndex","themeRef","cssVarsRef","common","cubicBezierEaseInOut","self","dotSize","dotColor","dotColorActive","dotColorFocus","dotLineWidth","dotLineWidthActive","arrowColor","themeClassHandle","mergedClsPrefix","duplicatedable","userWantsControl","slideStyles","translateStyle","slidesControlListeners","arrowSlotProps","dotSlotProps","cssVars","themeClass","onRender","render","$slots","defaultSlot","dots","dotsSlot","arrow","arrowSlot","children","slides","filterCarouselItem","ch","onResize","class","onMouseenter","onMouseleave","role","onTransitionend","key","vnodes","carouselItems","vnode"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/naive-ui/es/carousel/src/Carousel.mjs"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-argument */\nimport { h, defineComponent, ref, cloneVNode, computed, onBeforeUnmount, watch, withDirectives, vShow, Transition, toRef, nextTick, onMounted, watchEffect, normalizeStyle, onUpdated } from 'vue';\nimport { VResizeObserver } from 'vueuc';\nimport { useMergedState } from 'vooks';\nimport { on, off } from 'evtd';\nimport { getPreciseEventTarget } from 'seemly';\nimport { useConfig, useTheme, useThemeClass } from \"../../_mixins/index.mjs\";\nimport { flatten, keep, resolveSlotWithProps } from \"../../_utils/index.mjs\";\nimport { carouselLight } from \"../styles/index.mjs\";\nimport { calculateSize, clampValue, resolveSpeed, isTouchEvent, getNextIndex, getPrevIndex, getDisplayIndex, getRealIndex, getDisplayTotalView, addDuplicateSlides } from \"./utils/index.mjs\";\nimport { provideCarouselContext } from \"./CarouselContext.mjs\";\nimport NCarouselDots from \"./CarouselDots.mjs\";\nimport NCarouselArrow from \"./CarouselArrow.mjs\";\nimport NCarouselItem, { isCarouselItem } from \"./CarouselItem.mjs\";\nimport style from \"./styles/index.cssr.mjs\";\nconst transitionProperties = ['transitionDuration', 'transitionTimingFunction'];\nexport const carouselProps = Object.assign(Object.assign({}, useTheme.props), {\n  defaultIndex: {\n    type: Number,\n    default: 0\n  },\n  currentIndex: Number,\n  showArrow: Boolean,\n  dotType: {\n    type: String,\n    default: 'dot'\n  },\n  dotPlacement: {\n    type: String,\n    default: 'bottom'\n  },\n  slidesPerView: {\n    type: [Number, String],\n    default: 1\n  },\n  spaceBetween: {\n    type: Number,\n    default: 0\n  },\n  centeredSlides: Boolean,\n  direction: {\n    type: String,\n    default: 'horizontal'\n  },\n  autoplay: Boolean,\n  interval: {\n    type: Number,\n    default: 5000\n  },\n  loop: {\n    type: Boolean,\n    default: true\n  },\n  effect: {\n    type: String,\n    default: 'slide'\n  },\n  showDots: {\n    type: Boolean,\n    default: true\n  },\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  transitionStyle: {\n    type: Object,\n    default: () => ({\n      transitionDuration: '300ms'\n    })\n  },\n  transitionProps: Object,\n  draggable: Boolean,\n  prevSlideStyle: [Object, String],\n  nextSlideStyle: [Object, String],\n  touchable: {\n    type: Boolean,\n    default: true\n  },\n  mousewheel: Boolean,\n  keyboard: Boolean,\n  'onUpdate:currentIndex': Function,\n  onUpdateCurrentIndex: Function\n});\n// only one carousel is allowed to trigger touch globally\nlet globalDragging = false;\nexport default defineComponent({\n  name: 'Carousel',\n  props: carouselProps,\n  setup(props) {\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    // Dom\n    const selfElRef = ref(null);\n    const slidesElRef = ref(null);\n    const slideElsRef = ref([]);\n    const slideVNodesRef = {\n      value: []\n    };\n    // Computed states\n    const verticalRef = computed(() => props.direction === 'vertical');\n    const sizeAxisRef = computed(() => verticalRef.value ? 'height' : 'width');\n    const spaceAxisRef = computed(() => verticalRef.value ? 'bottom' : 'right');\n    const sequenceLayoutRef = computed(() => props.effect === 'slide');\n    const duplicatedableRef = computed(\n    // duplicate the copy operation in `slide` mode,\n    // because only its DOM is sequence layout\n    () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value);\n    // user wants to control the transition animation\n    const userWantsControlRef = computed(() => props.effect === 'custom');\n    // used to calculate total views\n    const displaySlidesPerViewRef = computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView);\n    // used to calculate the size of each slide\n    const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);\n    // we automatically calculate total view for special slides per view\n    const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' || props.slidesPerView === 'auto' && props.centeredSlides);\n    // Carousel size\n    const perViewSizeRef = ref({\n      width: 0,\n      height: 0\n    });\n    const slideSizesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      if (!slidesEls.length) return [];\n      const {\n        value: autoSlideSize\n      } = autoSlideSizeRef;\n      if (autoSlideSize) {\n        return slidesEls.map(slide => calculateSize(slide));\n      }\n      const {\n        value: slidesPerView\n      } = realSlidesPerViewRef;\n      const {\n        value: perViewSize\n      } = perViewSizeRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      let axisSize = perViewSize[axis];\n      if (slidesPerView !== 'auto') {\n        const {\n          spaceBetween\n        } = props;\n        const remaining = axisSize - (slidesPerView - 1) * spaceBetween;\n        const percentage = 1 / Math.max(1, slidesPerView);\n        axisSize = remaining * percentage;\n      }\n      const slideSize = Object.assign(Object.assign({}, perViewSize), {\n        [axis]: axisSize\n      });\n      return slidesEls.map(() => slideSize);\n    });\n    // The translate required to reach each slide\n    const slideTranlatesRef = computed(() => {\n      const {\n        value: slideSizes\n      } = slideSizesRef;\n      if (!slideSizes.length) return [];\n      const {\n        centeredSlides,\n        spaceBetween\n      } = props;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const {\n        [axis]: perViewSize\n      } = perViewSizeRef.value;\n      let previousTranslate = 0;\n      return slideSizes.map(({\n        [axis]: slideSize\n      }) => {\n        let translate = previousTranslate;\n        if (centeredSlides) {\n          translate += (slideSize - perViewSize) / 2;\n        }\n        previousTranslate += slideSize + spaceBetween;\n        return translate;\n      });\n    });\n    // Styles\n    const isMountedRef = ref(false);\n    const transitionStyleRef = computed(() => {\n      const {\n        transitionStyle\n      } = props;\n      return transitionStyle ? keep(transitionStyle, transitionProperties) : {};\n    });\n    const speedRef = computed(() => userWantsControlRef.value ? 0 : resolveSpeed(transitionStyleRef.value.transitionDuration));\n    const slideStylesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      if (!slidesEls.length) return [];\n      const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);\n      const getSlideSize = index => {\n        if (useComputedSize) {\n          const {\n            value: axis\n          } = sizeAxisRef;\n          return {\n            [axis]: `${slideSizesRef.value[index][axis]}px`\n          };\n        }\n      };\n      if (userWantsControlRef.value) {\n        // We center each slide when user wants to control the transition animation,\n        // so there is no need to calculate the offset\n        return slidesEls.map((_, i) => getSlideSize(i));\n      }\n      const {\n        effect,\n        spaceBetween\n      } = props;\n      const {\n        value: spaceAxis\n      } = spaceAxisRef;\n      return slidesEls.reduce((styles, _, i) => {\n        const style = Object.assign(Object.assign({}, getSlideSize(i)), {\n          [`margin-${spaceAxis}`]: `${spaceBetween}px`\n        });\n        styles.push(style);\n        if (isMountedRef.value && (effect === 'fade' || effect === 'card')) {\n          Object.assign(style, transitionStyleRef.value);\n        }\n        return styles;\n      }, []);\n    });\n    // Total\n    const totalViewRef = computed(() => {\n      const {\n        value: slidesPerView\n      } = displaySlidesPerViewRef;\n      const {\n        length: totalSlides\n      } = slideElsRef.value;\n      if (slidesPerView !== 'auto') {\n        return Math.max(totalSlides - slidesPerView, 0) + 1;\n      } else {\n        const {\n          value: slideSizes\n        } = slideSizesRef;\n        const {\n          length\n        } = slideSizes;\n        if (!length) return totalSlides;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis];\n        let lastViewSize = slideSizes[slideSizes.length - 1][axis];\n        let i = length;\n        while (i > 1 && lastViewSize < perViewSize) {\n          i--;\n          lastViewSize += translates[i] - translates[i - 1];\n        }\n        return clampValue(i + 1, 1, length);\n      }\n    });\n    const displayTotalViewRef = computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value));\n    // Index\n    const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);\n    const uncontrolledDisplayIndexRef = ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));\n    const mergedDisplayIndexRef = useMergedState(toRef(props, 'currentIndex'), uncontrolledDisplayIndexRef);\n    const realIndexRef = computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value));\n    // Reality methods\n    function toRealIndex(index) {\n      var _a, _b;\n      index = clampValue(index, 0, totalViewRef.value - 1);\n      const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);\n      const {\n        value: lastDisplayIndex\n      } = mergedDisplayIndexRef;\n      if (displayIndex !== mergedDisplayIndexRef.value) {\n        uncontrolledDisplayIndexRef.value = displayIndex;\n        (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);\n        (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);\n      }\n    }\n    function getRealPrevIndex(index = realIndexRef.value) {\n      return getPrevIndex(index, totalViewRef.value, props.loop);\n    }\n    function getRealNextIndex(index = realIndexRef.value) {\n      return getNextIndex(index, totalViewRef.value, props.loop);\n    }\n    function isRealPrev(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealPrevIndex() === index;\n    }\n    function isRealNext(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealNextIndex() === index;\n    }\n    function isRealActive(slideOrIndex) {\n      return realIndexRef.value === getSlideIndex(slideOrIndex);\n    }\n    // Display methods\n    // They are used to deal with the actual values displayed on the UI\n    function isDisplayActive(index) {\n      return mergedDisplayIndexRef.value === index;\n    }\n    function isPrevDisabled() {\n      return getRealPrevIndex() === null;\n    }\n    function isNextDisabled() {\n      return getRealNextIndex() === null;\n    }\n    // To\n    function to(index) {\n      const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);\n      if (index !== mergedDisplayIndexRef.value || realIndex !== realIndexRef.value) {\n        toRealIndex(realIndex);\n      }\n    }\n    function prev() {\n      const prevIndex = getRealPrevIndex();\n      if (prevIndex !== null) toRealIndex(prevIndex);\n    }\n    function next() {\n      const nextIndex = getRealNextIndex();\n      if (nextIndex !== null) toRealIndex(nextIndex);\n    }\n    function prevIfSlideTransitionEnd() {\n      if (!inTransition || !duplicatedableRef.value) prev();\n    }\n    function nextIfSlideTransitionEnd() {\n      if (!inTransition || !duplicatedableRef.value) next();\n    }\n    // Translate to\n    let inTransition = false;\n    // record the translate of each slide, so that it can be restored at touch\n    let previousTranslate = 0;\n    const translateStyleRef = ref({});\n    function updateTranslate(translate, speed = 0) {\n      translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {\n        transform: verticalRef.value ? `translateY(${-translate}px)` : `translateX(${-translate}px)`,\n        transitionDuration: `${speed}ms`\n      });\n    }\n    function fixTranslate(speed = 0) {\n      if (sequenceLayoutRef.value) {\n        translateTo(realIndexRef.value, speed);\n      } else if (previousTranslate !== 0) {\n        if (!inTransition && speed > 0) {\n          inTransition = true;\n        }\n        updateTranslate(previousTranslate = 0, speed);\n      }\n    }\n    function translateTo(index, speed) {\n      const translate = getTranslate(index);\n      if (translate !== previousTranslate && speed > 0) {\n        inTransition = true;\n      }\n      previousTranslate = getTranslate(realIndexRef.value);\n      updateTranslate(translate, speed);\n    }\n    function getTranslate(index) {\n      let translate;\n      // Deal with auto slides pre view\n      if (index >= totalViewRef.value - 1) {\n        translate = getLastViewTranslate();\n      } else {\n        translate = slideTranlatesRef.value[index] || 0;\n      }\n      return translate;\n    }\n    function getLastViewTranslate() {\n      if (displaySlidesPerViewRef.value === 'auto') {\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const {\n          [axis]: perViewSize\n        } = perViewSizeRef.value;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const lastTranslate = translates[translates.length - 1];\n        let overallSize;\n        if (lastTranslate === undefined) {\n          overallSize = perViewSize;\n        } else {\n          const {\n            value: slideSizes\n          } = slideSizesRef;\n          overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];\n        }\n        // Bring the last slide to the edge\n        return overallSize - perViewSize;\n      } else {\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        return translates[totalViewRef.value - 1] || 0;\n      }\n    }\n    // Provide\n    const carouselContext = {\n      currentIndexRef: mergedDisplayIndexRef,\n      to,\n      prev: prevIfSlideTransitionEnd,\n      next: nextIfSlideTransitionEnd,\n      isVertical: () => verticalRef.value,\n      isHorizontal: () => !verticalRef.value,\n      isPrev: isRealPrev,\n      isNext: isRealNext,\n      isActive: isRealActive,\n      isPrevDisabled,\n      isNextDisabled,\n      getSlideIndex,\n      getSlideStyle,\n      addSlide,\n      removeSlide,\n      onCarouselItemClick\n    };\n    provideCarouselContext(carouselContext);\n    function addSlide(slide) {\n      if (!slide) return;\n      slideElsRef.value.push(slide);\n    }\n    function removeSlide(slide) {\n      if (!slide) return;\n      const index = getSlideIndex(slide);\n      if (index !== -1) {\n        slideElsRef.value.splice(index, 1);\n      }\n    }\n    function getSlideIndex(slideOrIndex) {\n      return typeof slideOrIndex === 'number' ? slideOrIndex : slideOrIndex ? slideElsRef.value.indexOf(slideOrIndex) : -1;\n    }\n    function getSlideStyle(slide) {\n      const index = getSlideIndex(slide);\n      if (index !== -1) {\n        const styles = [slideStylesRef.value[index]];\n        const isPrev = carouselContext.isPrev(index);\n        const isNext = carouselContext.isNext(index);\n        if (isPrev) {\n          styles.push(props.prevSlideStyle || '');\n        }\n        if (isNext) {\n          styles.push(props.nextSlideStyle || '');\n        }\n        return normalizeStyle(styles);\n      }\n    }\n    function onCarouselItemClick(index, event) {\n      let allowClick = !inTransition && !dragging && !isEffectiveDrag;\n      if (props.effect === 'card' && allowClick && !isRealActive(index)) {\n        to(index);\n        allowClick = false;\n      }\n      if (!allowClick) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n    // Autoplay\n    let autoplayTimer = null;\n    function stopAutoplay() {\n      if (autoplayTimer) {\n        clearInterval(autoplayTimer);\n        autoplayTimer = null;\n      }\n    }\n    function resetAutoplay() {\n      stopAutoplay();\n      const disabled = !props.autoplay || displayTotalViewRef.value < 2;\n      if (!disabled) {\n        autoplayTimer = window.setInterval(next, props.interval);\n      }\n    }\n    // Drag\n    let dragStartX = 0;\n    let dragStartY = 0;\n    let dragOffset = 0;\n    let dragStartTime = 0;\n    let dragging = false;\n    let isEffectiveDrag = false;\n    function handleTouchstart(event) {\n      var _a;\n      if (globalDragging) return;\n      if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {\n        return;\n      }\n      globalDragging = true;\n      dragging = true;\n      isEffectiveDrag = false;\n      dragStartTime = Date.now();\n      stopAutoplay();\n      if (event.type !== 'touchstart' && !event.target.isContentEditable) {\n        event.preventDefault();\n      }\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n      if (verticalRef.value) {\n        dragStartY = touchEvent.clientY;\n      } else {\n        dragStartX = touchEvent.clientX;\n      }\n      if (props.touchable) {\n        on('touchmove', document, handleTouchmove);\n        on('touchend', document, handleTouchend);\n        on('touchcancel', document, handleTouchend);\n      }\n      if (props.draggable) {\n        on('mousemove', document, handleTouchmove);\n        on('mouseup', document, handleTouchend);\n      }\n    }\n    function handleTouchmove(event) {\n      const {\n        value: vertical\n      } = verticalRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n      const offset = vertical ? touchEvent.clientY - dragStartY : touchEvent.clientX - dragStartX;\n      const perViewSize = perViewSizeRef.value[axis];\n      dragOffset = clampValue(offset, -perViewSize, perViewSize);\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if (sequenceLayoutRef.value) {\n        updateTranslate(previousTranslate - dragOffset, 0);\n      }\n    }\n    function handleTouchend() {\n      const {\n        value: realIndex\n      } = realIndexRef;\n      let currentIndex = realIndex;\n      if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {\n        const currentTranslate = previousTranslate - dragOffset;\n        const translates = [...slideTranlatesRef.value.slice(0, totalViewRef.value - 1), getLastViewTranslate()];\n        let prevOffset = null;\n        for (let i = 0; i < translates.length; i++) {\n          const offset = Math.abs(translates[i] - currentTranslate);\n          if (prevOffset !== null && prevOffset < offset) {\n            break;\n          }\n          prevOffset = offset;\n          currentIndex = i;\n        }\n      }\n      if (currentIndex === realIndex) {\n        const timeElapsed = Date.now() - dragStartTime;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis];\n        // more than 50% width or faster than 0.4px per ms\n        if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {\n          currentIndex = getRealPrevIndex(realIndex);\n        } else if (dragOffset < -perViewSize / 2 || dragOffset / timeElapsed < -0.4) {\n          currentIndex = getRealNextIndex(realIndex);\n        }\n      }\n      if (currentIndex !== null && currentIndex !== realIndex) {\n        isEffectiveDrag = true;\n        toRealIndex(currentIndex);\n        void nextTick(() => {\n          if (!duplicatedableRef.value || uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {\n            fixTranslate(speedRef.value);\n          }\n        });\n      } else {\n        fixTranslate(speedRef.value);\n      }\n      resetDragStatus();\n      resetAutoplay();\n    }\n    function resetDragStatus() {\n      if (dragging) {\n        globalDragging = false;\n      }\n      dragging = false;\n      dragStartX = 0;\n      dragStartY = 0;\n      dragOffset = 0;\n      dragStartTime = 0;\n      off('touchmove', document, handleTouchmove);\n      off('touchend', document, handleTouchend);\n      off('touchcancel', document, handleTouchend);\n      off('mousemove', document, handleTouchmove);\n      off('mouseup', document, handleTouchend);\n    }\n    function handleTransitionEnd() {\n      if (sequenceLayoutRef.value && inTransition) {\n        const {\n          value: realIndex\n        } = realIndexRef;\n        translateTo(realIndex, 0);\n      } else {\n        resetAutoplay();\n      }\n      if (sequenceLayoutRef.value) {\n        translateStyleRef.value.transitionDuration = '0ms';\n      }\n      inTransition = false;\n    }\n    function handleMousewheel(event) {\n      event.preventDefault();\n      if (inTransition) return;\n      let {\n        deltaX,\n        deltaY\n      } = event;\n      if (event.shiftKey && !deltaX) {\n        deltaX = deltaY;\n      }\n      const prevMultiplier = -1;\n      const nextMultiplier = 1;\n      const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;\n      let rx = 0;\n      let ry = 0;\n      if (verticalRef.value) {\n        ry = m;\n      } else {\n        rx = m;\n      }\n      const responseStep = 10;\n      if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {\n        if (m === nextMultiplier && !isNextDisabled()) {\n          next();\n        } else if (m === prevMultiplier && !isPrevDisabled()) {\n          prev();\n        }\n      }\n    }\n    function handleResize() {\n      perViewSizeRef.value = calculateSize(selfElRef.value, true);\n      resetAutoplay();\n    }\n    function handleSlideResize() {\n      var _a, _b;\n      if (autoSlideSizeRef.value) {\n        (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);\n        slideSizesRef.effect.run();\n      }\n    }\n    function handleMouseenter() {\n      if (props.autoplay) {\n        stopAutoplay();\n      }\n    }\n    function handleMouseleave() {\n      if (props.autoplay) {\n        resetAutoplay();\n      }\n    }\n    onMounted(() => {\n      watchEffect(resetAutoplay);\n      requestAnimationFrame(() => isMountedRef.value = true);\n    });\n    onBeforeUnmount(() => {\n      resetDragStatus();\n      stopAutoplay();\n    });\n    // Fix index when remounting\n    onUpdated(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      const {\n        value: slideVNodes\n      } = slideVNodesRef;\n      const indexMap = new Map();\n      const getDisplayIndex = el =>\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      indexMap.has(el) ? indexMap.get(el) : -1;\n      let isChanged = false;\n      for (let i = 0; i < slidesEls.length; i++) {\n        const index = slideVNodes.findIndex(v => v.el === slidesEls[i]);\n        if (index !== i) {\n          isChanged = true;\n        }\n        indexMap.set(slidesEls[i], index);\n      }\n      if (isChanged) {\n        slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));\n      }\n    });\n    watch(realIndexRef, (realIndex, lastRealIndex) => {\n      if (realIndex === lastRealIndex) return;\n      resetAutoplay();\n      if (sequenceLayoutRef.value) {\n        if (duplicatedableRef.value) {\n          const {\n            value: length\n          } = totalViewRef;\n          if (displayTotalViewRef.value > 2 && realIndex === length - 2 && lastRealIndex === 1) {\n            realIndex = 0;\n          } else if (realIndex === 1 && lastRealIndex === length - 2) {\n            realIndex = length - 1;\n          }\n        }\n        translateTo(realIndex, speedRef.value);\n      } else {\n        fixTranslate();\n      }\n    }, {\n      immediate: true\n    });\n    watch([duplicatedableRef, displaySlidesPerViewRef], () => void nextTick(() => {\n      toRealIndex(realIndexRef.value);\n    }));\n    watch(slideTranlatesRef, () => {\n      sequenceLayoutRef.value && fixTranslate();\n    }, {\n      deep: true\n    });\n    watch(sequenceLayoutRef, value => {\n      if (!value) {\n        inTransition = false;\n        // if the current mode does not support translate, reset the position of the wrapper\n        updateTranslate(previousTranslate = 0);\n      } else {\n        fixTranslate();\n      }\n    });\n    const slidesControlListenersRef = computed(() => {\n      return {\n        onTouchstartPassive: props.touchable ? handleTouchstart : undefined,\n        onMousedown: props.draggable ? handleTouchstart : undefined,\n        onWheel: props.mousewheel ? handleMousewheel : undefined\n      };\n    });\n    const arrowSlotPropsRef = computed(() => Object.assign(Object.assign({}, keep(carouselContext, ['to', 'prev', 'next', 'isPrevDisabled', 'isNextDisabled'])), {\n      total: displayTotalViewRef.value,\n      currentIndex: mergedDisplayIndexRef.value\n    }));\n    const dotSlotPropsRef = computed(() => ({\n      total: displayTotalViewRef.value,\n      currentIndex: mergedDisplayIndexRef.value,\n      to: carouselContext.to\n    }));\n    const caroulseExposedMethod = {\n      getCurrentIndex: () => mergedDisplayIndexRef.value,\n      to,\n      prev,\n      next\n    };\n    const themeRef = useTheme('Carousel', '-carousel', style, carouselLight, props, mergedClsPrefixRef);\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          dotSize,\n          dotColor,\n          dotColorActive,\n          dotColorFocus,\n          dotLineWidth,\n          dotLineWidthActive,\n          arrowColor\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-dot-color': dotColor,\n        '--n-dot-color-focus': dotColorFocus,\n        '--n-dot-color-active': dotColorActive,\n        '--n-dot-size': dotSize,\n        '--n-dot-line-width': dotLineWidth,\n        '--n-dot-line-width-active': dotLineWidthActive,\n        '--n-arrow-color': arrowColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('carousel', undefined, cssVarsRef, props) : undefined;\n    return Object.assign(Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      selfElRef,\n      slidesElRef,\n      slideVNodes: slideVNodesRef,\n      duplicatedable: duplicatedableRef,\n      userWantsControl: userWantsControlRef,\n      autoSlideSize: autoSlideSizeRef,\n      realIndex: realIndexRef,\n      slideStyles: slideStylesRef,\n      translateStyle: translateStyleRef,\n      slidesControlListeners: slidesControlListenersRef,\n      handleTransitionEnd,\n      handleResize,\n      handleSlideResize,\n      handleMouseenter,\n      handleMouseleave,\n      isActive: isDisplayActive,\n      arrowSlotProps: arrowSlotPropsRef,\n      dotSlotProps: dotSlotPropsRef\n    }, caroulseExposedMethod), {\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n  render() {\n    var _a;\n    const {\n      mergedClsPrefix,\n      showArrow,\n      userWantsControl,\n      slideStyles,\n      dotType,\n      dotPlacement,\n      slidesControlListeners,\n      transitionProps = {},\n      arrowSlotProps,\n      dotSlotProps,\n      $slots: {\n        default: defaultSlot,\n        dots: dotsSlot,\n        arrow: arrowSlot\n      }\n    } = this;\n    const children = defaultSlot && flatten(defaultSlot()) || [];\n    let slides = filterCarouselItem(children);\n    if (!slides.length) {\n      slides = children.map(ch => h(NCarouselItem, null, {\n        default: () => cloneVNode(ch)\n      }));\n    }\n    if (this.duplicatedable) {\n      slides = addDuplicateSlides(slides);\n    }\n    this.slideVNodes.value = slides;\n    // When users need to customize the size of the slide,\n    // we listen to them to fix the current translate\n    if (this.autoSlideSize) {\n      slides = slides.map(slide => h(VResizeObserver, {\n        onResize: this.handleSlideResize\n      }, {\n        default: () => slide\n      }));\n    }\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    return h(\"div\", Object.assign({\n      ref: \"selfElRef\",\n      class: [this.themeClass, `${mergedClsPrefix}-carousel`, this.direction === 'vertical' && `${mergedClsPrefix}-carousel--vertical`, this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`, `${mergedClsPrefix}-carousel--${dotPlacement}`, `${mergedClsPrefix}-carousel--${this.direction}`, `${mergedClsPrefix}-carousel--${this.effect}`, userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`],\n      style: this.cssVars\n    }, slidesControlListeners, {\n      onMouseenter: this.handleMouseenter,\n      onMouseleave: this.handleMouseleave\n    }), h(VResizeObserver, {\n      onResize: this.handleResize\n    }, {\n      default: () => h(\"div\", {\n        ref: \"slidesElRef\",\n        class: `${mergedClsPrefix}-carousel__slides`,\n        role: \"listbox\",\n        style: this.translateStyle,\n        onTransitionend: this.handleTransitionEnd\n      }, userWantsControl ? slides.map((slide, i) => h(\"div\", {\n        style: slideStyles[i],\n        key: i\n      }, withDirectives(h(Transition, Object.assign({}, transitionProps), {\n        default: () => slide\n      }), [[vShow, this.isActive(i)]]))) : slides)\n    }), this.showDots && dotSlotProps.total > 1 && resolveSlotWithProps(dotsSlot, dotSlotProps, () => [h(NCarouselDots, {\n      key: dotType + dotPlacement,\n      total: dotSlotProps.total,\n      currentIndex: dotSlotProps.currentIndex,\n      dotType: dotType,\n      trigger: this.trigger,\n      keyboard: this.keyboard\n    })]), showArrow && resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [h(NCarouselArrow, null)]));\n  }\n});\nfunction filterCarouselItem(vnodes) {\n  return vnodes.reduce((carouselItems, vnode) => {\n    if (isCarouselItem(vnode)) {\n      carouselItems.push(vnode);\n    }\n    return carouselItems;\n  }, []);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}