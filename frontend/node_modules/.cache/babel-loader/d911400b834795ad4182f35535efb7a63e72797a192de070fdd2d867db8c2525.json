{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport { h, ref, defineComponent, computed, provide, watch, toRef, nextTick, withDirectives, vShow, watchEffect, cloneVNode, TransitionGroup, onMounted } from 'vue';\nimport { VResizeObserver, VXScroll } from 'vueuc';\nimport { throttle } from 'lodash-es';\nimport { useCompitable, onFontsReady, useMergedState } from 'vooks';\nimport { useConfig, useTheme, useThemeClass } from \"../../_mixins/index.mjs\";\nimport { createKey, call, flatten, warnOnce, resolveWrappedSlot } from \"../../_utils/index.mjs\";\nimport { tabsLight } from \"../styles/index.mjs\";\nimport { tabsInjectionKey } from \"./interface.mjs\";\nimport Tab from \"./Tab.mjs\";\nimport style from \"./styles/index.cssr.mjs\";\nimport { depx, getPadding } from 'seemly';\nexport const tabsProps = Object.assign(Object.assign({}, useTheme.props), {\n  value: [String, Number],\n  defaultValue: [String, Number],\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  type: {\n    type: String,\n    default: 'bar'\n  },\n  closable: Boolean,\n  justifyContent: String,\n  size: {\n    type: String,\n    default: 'medium'\n  },\n  placement: {\n    type: String,\n    default: 'top'\n  },\n  tabStyle: [String, Object],\n  tabClass: String,\n  addTabStyle: [String, Object],\n  addTabClass: String,\n  barWidth: Number,\n  paneClass: String,\n  paneStyle: [String, Object],\n  paneWrapperClass: String,\n  paneWrapperStyle: [String, Object],\n  addable: [Boolean, Object],\n  tabsPadding: {\n    type: Number,\n    default: 0\n  },\n  animated: Boolean,\n  onBeforeLeave: Function,\n  onAdd: Function,\n  'onUpdate:value': [Function, Array],\n  onUpdateValue: [Function, Array],\n  onClose: [Function, Array],\n  // deprecated\n  labelSize: String,\n  activeName: [String, Number],\n  onActiveNameChange: [Function, Array]\n});\nexport default defineComponent({\n  name: 'Tabs',\n  props: tabsProps,\n  setup(props, {\n    slots\n  }) {\n    var _a, _b, _c, _d;\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.labelSize !== undefined) {\n          warnOnce('tabs', '`label-size` is deprecated, please use `size` instead.');\n        }\n        if (props.activeName !== undefined) {\n          warnOnce('tabs', '`active-name` is deprecated, please use `value` instead.');\n        }\n        if (props.onActiveNameChange !== undefined) {\n          warnOnce('tabs', '`on-active-name-change` is deprecated, please use `on-update:value` instead.');\n        }\n      });\n    }\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    const themeRef = useTheme('Tabs', '-tabs', style, tabsLight, props, mergedClsPrefixRef);\n    const tabsElRef = ref(null);\n    const barElRef = ref(null);\n    const scrollWrapperElRef = ref(null);\n    const addTabInstRef = ref(null);\n    const xScrollInstRef = ref(null);\n    const yScrollElRef = ref(null);\n    const startReachedRef = ref(true);\n    const endReachedRef = ref(true);\n    const compitableSizeRef = useCompitable(props, ['labelSize', 'size']);\n    const compitableValueRef = useCompitable(props, ['activeName', 'value']);\n    const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);\n    const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);\n    const tabChangeIdRef = {\n      id: 0\n    };\n    const tabWrapperStyleRef = computed(() => {\n      if (!props.justifyContent || props.type === 'card') return undefined;\n      return {\n        display: 'flex',\n        justifyContent: props.justifyContent\n      };\n    });\n    watch(mergedValueRef, () => {\n      tabChangeIdRef.id = 0;\n      updateCurrentBarStyle();\n      updateCurrentScrollPosition(true);\n    });\n    function getCurrentEl() {\n      var _a;\n      const {\n        value\n      } = mergedValueRef;\n      if (value === null) return null;\n      const tabEl = (_a = tabsElRef.value) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-name=\"${value}\"]`);\n      return tabEl;\n    }\n    function updateBarStyle(tabEl) {\n      if (props.type === 'card') return;\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      const barIsHide = barEl.style.opacity === '0';\n      if (tabEl) {\n        const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;\n        const {\n          barWidth,\n          placement\n        } = props;\n        if (tabEl.dataset.disabled === 'true') {\n          barEl.classList.add(disabledClassName);\n        } else {\n          barEl.classList.remove(disabledClassName);\n        }\n        if (['top', 'bottom'].includes(placement)) {\n          clearBarStyle(['top', 'maxHeight', 'height']);\n          if (typeof barWidth === 'number' && tabEl.offsetWidth >= barWidth) {\n            const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;\n            barEl.style.left = `${offsetDiffLeft}px`;\n            barEl.style.maxWidth = `${barWidth}px`;\n          } else {\n            barEl.style.left = `${tabEl.offsetLeft}px`;\n            barEl.style.maxWidth = `${tabEl.offsetWidth}px`;\n          }\n          barEl.style.width = '8192px';\n          if (barIsHide) {\n            barEl.style.transition = 'none';\n          }\n          void barEl.offsetWidth;\n          if (barIsHide) {\n            barEl.style.transition = '';\n            barEl.style.opacity = '1';\n          }\n        } else {\n          clearBarStyle(['left', 'maxWidth', 'width']);\n          if (typeof barWidth === 'number' && tabEl.offsetHeight >= barWidth) {\n            const offsetDiffTop = Math.floor((tabEl.offsetHeight - barWidth) / 2) + tabEl.offsetTop;\n            barEl.style.top = `${offsetDiffTop}px`;\n            barEl.style.maxHeight = `${barWidth}px`;\n          } else {\n            barEl.style.top = `${tabEl.offsetTop}px`;\n            barEl.style.maxHeight = `${tabEl.offsetHeight}px`;\n          }\n          barEl.style.height = '8192px';\n          if (barIsHide) {\n            barEl.style.transition = 'none';\n          }\n          void barEl.offsetHeight;\n          if (barIsHide) {\n            barEl.style.transition = '';\n            barEl.style.opacity = '1';\n          }\n        }\n      }\n    }\n    function hideBarStyle() {\n      if (props.type === 'card') return;\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      barEl.style.opacity = '0';\n    }\n    function clearBarStyle(styleProps) {\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      for (const prop of styleProps) {\n        barEl.style[prop] = '';\n      }\n    }\n    function updateCurrentBarStyle() {\n      if (props.type === 'card') return;\n      const tabEl = getCurrentEl();\n      if (tabEl) {\n        updateBarStyle(tabEl);\n      } else {\n        hideBarStyle();\n      }\n    }\n    function updateCurrentScrollPosition(smooth) {\n      var _a;\n      const scrollWrapperEl = (_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;\n      if (!scrollWrapperEl) return;\n      const tabEl = getCurrentEl();\n      if (!tabEl) return;\n      const {\n        scrollLeft: scrollWrapperElScrollLeft,\n        offsetWidth: scrollWrapperElOffsetWidth\n      } = scrollWrapperEl;\n      const {\n        offsetLeft: tabElOffsetLeft,\n        offsetWidth: tabElOffsetWidth\n      } = tabEl;\n      if (scrollWrapperElScrollLeft > tabElOffsetLeft) {\n        scrollWrapperEl.scrollTo({\n          top: 0,\n          left: tabElOffsetLeft,\n          behavior: 'smooth'\n        });\n      } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {\n        scrollWrapperEl.scrollTo({\n          top: 0,\n          left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,\n          behavior: 'smooth'\n        });\n      }\n    }\n    const tabsPaneWrapperRef = ref(null);\n    let fromHeight = 0;\n    let hangingTransition = null;\n    function onAnimationBeforeLeave(el) {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        fromHeight = el.getBoundingClientRect().height;\n        const fromHeightPx = `${fromHeight}px`;\n        const applyFromStyle = () => {\n          tabsPaneWrapperEl.style.height = fromHeightPx;\n          tabsPaneWrapperEl.style.maxHeight = fromHeightPx;\n        };\n        if (!hangingTransition) {\n          hangingTransition = applyFromStyle;\n        } else {\n          applyFromStyle();\n          hangingTransition();\n          hangingTransition = null;\n        }\n      }\n    }\n    function onAnimationEnter(el) {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        const targetHeight = el.getBoundingClientRect().height;\n        const applyTargetStyle = () => {\n          void document.body.offsetHeight;\n          tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;\n          tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;\n        };\n        if (!hangingTransition) {\n          hangingTransition = applyTargetStyle;\n        } else {\n          hangingTransition();\n          hangingTransition = null;\n          applyTargetStyle();\n        }\n      }\n    }\n    function onAnimationAfterEnter() {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        tabsPaneWrapperEl.style.maxHeight = '';\n        tabsPaneWrapperEl.style.height = '';\n        const {\n          paneWrapperStyle\n        } = props;\n        if (typeof paneWrapperStyle === 'string') {\n          tabsPaneWrapperEl.style.cssText = paneWrapperStyle;\n        } else if (paneWrapperStyle) {\n          const {\n            maxHeight,\n            height\n          } = paneWrapperStyle;\n          if (maxHeight !== undefined) {\n            tabsPaneWrapperEl.style.maxHeight = maxHeight;\n          }\n          if (height !== undefined) {\n            tabsPaneWrapperEl.style.height = height;\n          }\n        }\n      }\n    }\n    const renderNameListRef = {\n      value: []\n    };\n    const animationDirectionRef = ref('next');\n    function activateTab(panelName) {\n      const currentValue = mergedValueRef.value;\n      let dir = 'next';\n      for (const name of renderNameListRef.value) {\n        if (name === currentValue) {\n          break;\n        }\n        if (name === panelName) {\n          dir = 'prev';\n          break;\n        }\n      }\n      animationDirectionRef.value = dir;\n      doUpdateValue(panelName);\n    }\n    function doUpdateValue(panelName) {\n      const {\n        onActiveNameChange,\n        onUpdateValue,\n        'onUpdate:value': _onUpdateValue\n      } = props;\n      if (onActiveNameChange) {\n        call(onActiveNameChange, panelName);\n      }\n      if (onUpdateValue) call(onUpdateValue, panelName);\n      if (_onUpdateValue) call(_onUpdateValue, panelName);\n      uncontrolledValueRef.value = panelName;\n    }\n    function handleClose(panelName) {\n      const {\n        onClose\n      } = props;\n      if (onClose) call(onClose, panelName);\n    }\n    let firstTimeUpdatePosition = true;\n    function updateBarPositionInstantly() {\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      if (!firstTimeUpdatePosition) firstTimeUpdatePosition = false;\n      const disableTransitionClassName = 'transition-disabled';\n      barEl.classList.add(disableTransitionClassName);\n      updateCurrentBarStyle();\n      // here we don't need to force layout after update bar style\n      // since deriveScrollShadow will force layout\n      barEl.classList.remove(disableTransitionClassName);\n    }\n    const segmentCapsuleElRef = ref(null);\n    function updateSegmentPosition({\n      transitionDisabled\n    }) {\n      const tabsEl = tabsElRef.value;\n      if (!tabsEl) return;\n      transitionDisabled && tabsEl.classList.add('transition-disabled');\n      const activeTabEl = getCurrentEl();\n      if (activeTabEl && segmentCapsuleElRef.value) {\n        // move segment capsule to match the position of the active tab\n        segmentCapsuleElRef.value.style.width = `${activeTabEl.offsetWidth}px`;\n        segmentCapsuleElRef.value.style.height = `${activeTabEl.offsetHeight}px`;\n        segmentCapsuleElRef.value.style.transform = `translateX(${activeTabEl.offsetLeft - depx(getComputedStyle(tabsEl).paddingLeft)}px)`;\n        if (transitionDisabled) {\n          void segmentCapsuleElRef.value.offsetWidth;\n        }\n      }\n      transitionDisabled && tabsEl.classList.remove('transition-disabled');\n    }\n    watch([mergedValueRef], () => {\n      if (props.type === 'segment') {\n        void nextTick(() => {\n          updateSegmentPosition({\n            transitionDisabled: false\n          });\n        });\n      }\n    });\n    onMounted(() => {\n      if (props.type === 'segment') {\n        updateSegmentPosition({\n          transitionDisabled: true\n        });\n      }\n    });\n    let memorizedWidth = 0;\n    function _handleNavResize(entry) {\n      var _a, _b;\n      if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {\n        return;\n      }\n      if (memorizedWidth === entry.contentRect.width) {\n        return;\n      }\n      memorizedWidth = entry.contentRect.width;\n      const {\n        type\n      } = props;\n      if (type === 'line' || type === 'bar') {\n        if (firstTimeUpdatePosition || ((_a = props.justifyContent) === null || _a === void 0 ? void 0 : _a.startsWith('space'))) {\n          updateBarPositionInstantly();\n        }\n      }\n      if (type !== 'segment') {\n        const {\n          placement\n        } = props;\n        deriveScrollShadow((placement === 'top' || placement === 'bottom' ? (_b = xScrollInstRef.value) === null || _b === void 0 ? void 0 : _b.$el : yScrollElRef.value) || null);\n      }\n    }\n    const handleNavResize = throttle(_handleNavResize, 64);\n    watch([() => props.justifyContent, () => props.size], () => {\n      void nextTick(() => {\n        const {\n          type\n        } = props;\n        if (type === 'line' || type === 'bar') {\n          updateBarPositionInstantly();\n        }\n      });\n    });\n    const addTabFixedRef = ref(false);\n    function _handleTabsResize(entry) {\n      var _a;\n      const {\n        target,\n        contentRect: {\n          width\n        }\n      } = entry;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const containerWidth = target.parentElement.offsetWidth;\n      if (!addTabFixedRef.value) {\n        if (containerWidth < width) {\n          addTabFixedRef.value = true;\n        }\n      } else {\n        const {\n          value: addTabInst\n        } = addTabInstRef;\n        if (!addTabInst) return;\n        if (containerWidth - width > addTabInst.$el.offsetWidth) {\n          addTabFixedRef.value = false;\n        }\n      }\n      deriveScrollShadow(((_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) || null);\n    }\n    const handleTabsResize = throttle(_handleTabsResize, 64);\n    function handleAdd() {\n      const {\n        onAdd\n      } = props;\n      if (onAdd) onAdd();\n      void nextTick(() => {\n        const currentEl = getCurrentEl();\n        const {\n          value: xScrollInst\n        } = xScrollInstRef;\n        if (!currentEl || !xScrollInst) return;\n        xScrollInst.scrollTo({\n          left: currentEl.offsetLeft,\n          top: 0,\n          behavior: 'smooth'\n        });\n      });\n    }\n    function deriveScrollShadow(el) {\n      if (!el) return;\n      const {\n        placement\n      } = props;\n      if (placement === 'top' || placement === 'bottom') {\n        const {\n          scrollLeft,\n          scrollWidth,\n          offsetWidth\n        } = el;\n        startReachedRef.value = scrollLeft <= 0;\n        endReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;\n      } else {\n        const {\n          scrollTop,\n          scrollHeight,\n          offsetHeight\n        } = el;\n        startReachedRef.value = scrollTop <= 0;\n        endReachedRef.value = scrollTop + offsetHeight >= scrollHeight;\n      }\n    }\n    const handleScroll = throttle(e => {\n      deriveScrollShadow(e.target);\n    }, 64);\n    provide(tabsInjectionKey, {\n      triggerRef: toRef(props, 'trigger'),\n      tabStyleRef: toRef(props, 'tabStyle'),\n      tabClassRef: toRef(props, 'tabClass'),\n      addTabStyleRef: toRef(props, 'addTabStyle'),\n      addTabClassRef: toRef(props, 'addTabClass'),\n      paneClassRef: toRef(props, 'paneClass'),\n      paneStyleRef: toRef(props, 'paneStyle'),\n      mergedClsPrefixRef,\n      typeRef: toRef(props, 'type'),\n      closableRef: toRef(props, 'closable'),\n      valueRef: mergedValueRef,\n      tabChangeIdRef,\n      onBeforeLeaveRef: toRef(props, 'onBeforeLeave'),\n      activateTab,\n      handleClose,\n      handleAdd\n    });\n    onFontsReady(() => {\n      updateCurrentBarStyle();\n      updateCurrentScrollPosition(true);\n    });\n    // avoid useless rerender\n    watchEffect(() => {\n      const {\n        value: el\n      } = scrollWrapperElRef;\n      if (!el) return;\n      const {\n        value: clsPrefix\n      } = mergedClsPrefixRef;\n      const shadowStartClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-start`;\n      const shadowEndClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-end`;\n      if (startReachedRef.value) {\n        el.classList.remove(shadowStartClass);\n      } else {\n        el.classList.add(shadowStartClass);\n      }\n      if (endReachedRef.value) {\n        el.classList.remove(shadowEndClass);\n      } else {\n        el.classList.add(shadowEndClass);\n      }\n    });\n    const exposedMethods = {\n      syncBarPosition: () => {\n        updateCurrentBarStyle();\n      }\n    };\n    const handleSegmentResize = () => {\n      updateSegmentPosition({\n        transitionDisabled: true\n      });\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        value: size\n      } = compitableSizeRef;\n      const {\n        type\n      } = props;\n      const typeSuffix = {\n        card: 'Card',\n        bar: 'Bar',\n        line: 'Line',\n        segment: 'Segment'\n      }[type];\n      const sizeType = `${size}${typeSuffix}`;\n      const {\n        self: {\n          barColor,\n          closeIconColor,\n          closeIconColorHover,\n          closeIconColorPressed,\n          tabColor,\n          tabBorderColor,\n          paneTextColor,\n          tabFontWeight,\n          tabBorderRadius,\n          tabFontWeightActive,\n          colorSegment,\n          fontWeightStrong,\n          tabColorSegment,\n          closeSize,\n          closeIconSize,\n          closeColorHover,\n          closeColorPressed,\n          closeBorderRadius,\n          [createKey('panePadding', size)]: panePadding,\n          [createKey('tabPadding', sizeType)]: tabPadding,\n          [createKey('tabPaddingVertical', sizeType)]: tabPaddingVertical,\n          [createKey('tabGap', sizeType)]: tabGap,\n          [createKey('tabGap', `${sizeType}Vertical`)]: tabGapVertical,\n          [createKey('tabTextColor', type)]: tabTextColor,\n          [createKey('tabTextColorActive', type)]: tabTextColorActive,\n          [createKey('tabTextColorHover', type)]: tabTextColorHover,\n          [createKey('tabTextColorDisabled', type)]: tabTextColorDisabled,\n          [createKey('tabFontSize', size)]: tabFontSize\n        },\n        common: {\n          cubicBezierEaseInOut\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-color-segment': colorSegment,\n        '--n-bar-color': barColor,\n        '--n-tab-font-size': tabFontSize,\n        '--n-tab-text-color': tabTextColor,\n        '--n-tab-text-color-active': tabTextColorActive,\n        '--n-tab-text-color-disabled': tabTextColorDisabled,\n        '--n-tab-text-color-hover': tabTextColorHover,\n        '--n-pane-text-color': paneTextColor,\n        '--n-tab-border-color': tabBorderColor,\n        '--n-tab-border-radius': tabBorderRadius,\n        '--n-close-size': closeSize,\n        '--n-close-icon-size': closeIconSize,\n        '--n-close-color-hover': closeColorHover,\n        '--n-close-color-pressed': closeColorPressed,\n        '--n-close-border-radius': closeBorderRadius,\n        '--n-close-icon-color': closeIconColor,\n        '--n-close-icon-color-hover': closeIconColorHover,\n        '--n-close-icon-color-pressed': closeIconColorPressed,\n        '--n-tab-color': tabColor,\n        '--n-tab-font-weight': tabFontWeight,\n        '--n-tab-font-weight-active': tabFontWeightActive,\n        '--n-tab-padding': tabPadding,\n        '--n-tab-padding-vertical': tabPaddingVertical,\n        '--n-tab-gap': tabGap,\n        '--n-tab-gap-vertical': tabGapVertical,\n        '--n-pane-padding-left': getPadding(panePadding, 'left'),\n        '--n-pane-padding-right': getPadding(panePadding, 'right'),\n        '--n-pane-padding-top': getPadding(panePadding, 'top'),\n        '--n-pane-padding-bottom': getPadding(panePadding, 'bottom'),\n        '--n-font-weight-strong': fontWeightStrong,\n        '--n-tab-color-segment': tabColorSegment\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tabs', computed(() => {\n      return `${compitableSizeRef.value[0]}${props.type[0]}`;\n    }), cssVarsRef, props) : undefined;\n    return Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedValue: mergedValueRef,\n      renderedNames: new Set(),\n      segmentCapsuleElRef,\n      tabsPaneWrapperRef,\n      tabsElRef,\n      barElRef,\n      addTabInstRef,\n      xScrollInstRef,\n      scrollWrapperElRef,\n      addTabFixed: addTabFixedRef,\n      tabWrapperStyle: tabWrapperStyleRef,\n      handleNavResize,\n      mergedSize: compitableSizeRef,\n      handleScroll,\n      handleTabsResize,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      animationDirection: animationDirectionRef,\n      renderNameListRef,\n      yScrollElRef,\n      handleSegmentResize,\n      onAnimationBeforeLeave,\n      onAnimationEnter,\n      onAnimationAfterEnter,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    }, exposedMethods);\n  },\n  render() {\n    const {\n      mergedClsPrefix,\n      type,\n      placement,\n      addTabFixed,\n      addable,\n      mergedSize,\n      renderNameListRef,\n      onRender,\n      paneWrapperClass,\n      paneWrapperStyle,\n      $slots: {\n        default: defaultSlot,\n        prefix: prefixSlot,\n        suffix: suffixSlot\n      }\n    } = this;\n    onRender === null || onRender === void 0 ? void 0 : onRender();\n    const tabPaneChildren = defaultSlot ? flatten(defaultSlot()).filter(v => {\n      return v.type.__TAB_PANE__ === true;\n    }) : [];\n    const tabChildren = defaultSlot ? flatten(defaultSlot()).filter(v => {\n      return v.type.__TAB__ === true;\n    }) : [];\n    const showPane = !tabChildren.length;\n    const isCard = type === 'card';\n    const isSegment = type === 'segment';\n    const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;\n    renderNameListRef.value = [];\n    const scrollContent = () => {\n      const tabs = h(\"div\", {\n        style: this.tabWrapperStyle,\n        class: [`${mergedClsPrefix}-tabs-wrapper`]\n      }, mergedJustifyContent ? null : h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-scroll-padding`,\n        style: {\n          width: `${this.tabsPadding}px`\n        }\n      }), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {\n        renderNameListRef.value.push(tabPaneVNode.props.name);\n        return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, {\n          internalCreatedByPane: true,\n          internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === 'center' || mergedJustifyContent === 'start' || mergedJustifyContent === 'end')\n        }), tabPaneVNode.children ? {\n          default: tabPaneVNode.children.tab\n        } : undefined));\n      }) : tabChildren.map((tabVNode, index) => {\n        renderNameListRef.value.push(tabVNode.props.name);\n        if (index !== 0 && !mergedJustifyContent) {\n          return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));\n        } else {\n          return justifyTabDynamicProps(tabVNode);\n        }\n      }), !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null, mergedJustifyContent ? null : h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-scroll-padding`,\n        style: {\n          width: `${this.tabsPadding}px`\n        }\n      }));\n      return h(\"div\", {\n        ref: \"tabsElRef\",\n        class: `${mergedClsPrefix}-tabs-nav-scroll-content`\n      }, isCard && addable ? h(VResizeObserver, {\n        onResize: this.handleTabsResize\n      }, {\n        default: () => tabs\n      }) : tabs, isCard ? h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-pad`\n      }) : null, isCard ? null : h(\"div\", {\n        ref: \"barElRef\",\n        class: `${mergedClsPrefix}-tabs-bar`\n      }));\n    };\n    const resolvedPlacement = isSegment ? 'top' : placement;\n    return h(\"div\", {\n      class: [`${mergedClsPrefix}-tabs`, this.themeClass, `${mergedClsPrefix}-tabs--${type}-type`, `${mergedClsPrefix}-tabs--${mergedSize}-size`, mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`, `${mergedClsPrefix}-tabs--${resolvedPlacement}`],\n      style: this.cssVars\n    }, h(\"div\", {\n      class: [\n      // the class should be applied here since it's possible\n      // to make tabs nested in tabs, style may influence each\n      // other. adding a class will make it easy to write the\n      // style.\n      `${mergedClsPrefix}-tabs-nav--${type}-type`, `${mergedClsPrefix}-tabs-nav--${resolvedPlacement}`, `${mergedClsPrefix}-tabs-nav`]\n    }, resolveWrappedSlot(prefixSlot, children => children && h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-nav__prefix`\n    }, children)), isSegment ? h(VResizeObserver, {\n      onResize: this.handleSegmentResize\n    }, {\n      default: () => h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-rail`,\n        ref: \"tabsElRef\"\n      }, h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-capsule`,\n        ref: \"segmentCapsuleElRef\"\n      }, h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-wrapper`\n      }, h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-tab`\n      }))), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {\n        renderNameListRef.value.push(tabPaneVNode.props.name);\n        return h(Tab, Object.assign({}, tabPaneVNode.props, {\n          internalCreatedByPane: true,\n          internalLeftPadded: index !== 0\n        }), tabPaneVNode.children ? {\n          default: tabPaneVNode.children.tab\n        } : undefined);\n      }) : tabChildren.map((tabVNode, index) => {\n        renderNameListRef.value.push(tabVNode.props.name);\n        if (index === 0) {\n          return tabVNode;\n        } else {\n          return createLeftPaddedTabVNode(tabVNode);\n        }\n      }))\n    }) : h(VResizeObserver, {\n      onResize: this.handleNavResize\n    }, {\n      default: () => h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`,\n        ref: \"scrollWrapperElRef\"\n      }, ['top', 'bottom'].includes(resolvedPlacement) ? h(VXScroll, {\n        ref: \"xScrollInstRef\",\n        onScroll: this.handleScroll\n      }, {\n        default: scrollContent\n      }) : h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-nav-y-scroll`,\n        onScroll: this.handleScroll,\n        ref: \"yScrollElRef\"\n      }, scrollContent()))\n    }), addTabFixed && addable && isCard ? createAddTag(addable, true) : null, resolveWrappedSlot(suffixSlot, children => children && h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-nav__suffix`\n    }, children))), showPane && (this.animated && (resolvedPlacement === 'top' || resolvedPlacement === 'bottom') ? h(\"div\", {\n      ref: \"tabsPaneWrapperRef\",\n      style: paneWrapperStyle,\n      class: [`${mergedClsPrefix}-tabs-pane-wrapper`, paneWrapperClass]\n    }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)));\n  }\n});\nfunction filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {\n  const children = [];\n  tabPaneVNodes.forEach(vNode => {\n    const {\n      name,\n      displayDirective,\n      'display-directive': _displayDirective\n    } = vNode.props;\n    const matchDisplayDirective = directive => displayDirective === directive || _displayDirective === directive;\n    const show = value === name;\n    if (vNode.key !== undefined) {\n      vNode.key = name;\n    }\n    if (show || matchDisplayDirective('show') || matchDisplayDirective('show:lazy') && renderedNames.has(name)) {\n      if (!renderedNames.has(name)) {\n        renderedNames.add(name);\n      }\n      const useVShow = !matchDisplayDirective('if');\n      children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);\n    }\n  });\n  if (!animationDirection) {\n    return children;\n  }\n  return h(TransitionGroup, {\n    name: `${animationDirection}-transition`,\n    onBeforeLeave: onBeforeLeave,\n    onEnter: onEnter,\n    onAfterEnter: onAfterEnter\n  }, {\n    default: () => children\n  });\n}\nfunction createAddTag(addable, internalLeftPadded) {\n  return h(Tab, {\n    ref: \"addTabInstRef\",\n    key: \"__addable\",\n    name: \"__addable\",\n    internalCreatedByPane: true,\n    internalAddable: true,\n    internalLeftPadded: internalLeftPadded,\n    disabled: typeof addable === 'object' && addable.disabled\n  });\n}\nfunction createLeftPaddedTabVNode(tabVNode) {\n  const modifiedVNode = cloneVNode(tabVNode);\n  if (modifiedVNode.props) {\n    modifiedVNode.props.internalLeftPadded = true;\n  } else {\n    modifiedVNode.props = {\n      internalLeftPadded: true\n    };\n  }\n  return modifiedVNode;\n}\nfunction justifyTabDynamicProps(tabVNode) {\n  if (Array.isArray(tabVNode.dynamicProps)) {\n    if (!tabVNode.dynamicProps.includes('internalLeftPadded')) {\n      tabVNode.dynamicProps.push('internalLeftPadded');\n    }\n  } else {\n    tabVNode.dynamicProps = ['internalLeftPadded'];\n  }\n  return tabVNode;\n}","map":{"version":3,"names":["h","ref","defineComponent","computed","provide","watch","toRef","nextTick","withDirectives","vShow","watchEffect","cloneVNode","TransitionGroup","onMounted","VResizeObserver","VXScroll","throttle","useCompitable","onFontsReady","useMergedState","useConfig","useTheme","useThemeClass","createKey","call","flatten","warnOnce","resolveWrappedSlot","tabsLight","tabsInjectionKey","Tab","style","depx","getPadding","tabsProps","Object","assign","props","value","String","Number","defaultValue","trigger","type","default","closable","Boolean","justifyContent","size","placement","tabStyle","tabClass","addTabStyle","addTabClass","barWidth","paneClass","paneStyle","paneWrapperClass","paneWrapperStyle","addable","tabsPadding","animated","onBeforeLeave","Function","onAdd","Array","onUpdateValue","onClose","labelSize","activeName","onActiveNameChange","name","setup","slots","_a","_b","_c","_d","process","env","NODE_ENV","undefined","mergedClsPrefixRef","inlineThemeDisabled","themeRef","tabsElRef","barElRef","scrollWrapperElRef","addTabInstRef","xScrollInstRef","yScrollElRef","startReachedRef","endReachedRef","compitableSizeRef","compitableValueRef","uncontrolledValueRef","mergedValueRef","tabChangeIdRef","id","tabWrapperStyleRef","display","updateCurrentBarStyle","updateCurrentScrollPosition","getCurrentEl","tabEl","querySelector","updateBarStyle","barEl","barIsHide","opacity","disabledClassName","dataset","disabled","classList","add","remove","includes","clearBarStyle","offsetWidth","offsetDiffLeft","Math","floor","offsetLeft","left","maxWidth","width","transition","offsetHeight","offsetDiffTop","offsetTop","top","maxHeight","height","hideBarStyle","styleProps","prop","smooth","scrollWrapperEl","$el","scrollLeft","scrollWrapperElScrollLeft","scrollWrapperElOffsetWidth","tabElOffsetLeft","tabElOffsetWidth","scrollTo","behavior","tabsPaneWrapperRef","fromHeight","hangingTransition","onAnimationBeforeLeave","el","tabsPaneWrapperEl","getBoundingClientRect","fromHeightPx","applyFromStyle","onAnimationEnter","targetHeight","applyTargetStyle","document","body","max","onAnimationAfterEnter","cssText","renderNameListRef","animationDirectionRef","activateTab","panelName","currentValue","dir","doUpdateValue","_onUpdateValue","handleClose","firstTimeUpdatePosition","updateBarPositionInstantly","disableTransitionClassName","segmentCapsuleElRef","updateSegmentPosition","transitionDisabled","tabsEl","activeTabEl","transform","getComputedStyle","paddingLeft","memorizedWidth","_handleNavResize","entry","contentRect","startsWith","deriveScrollShadow","handleNavResize","addTabFixedRef","_handleTabsResize","target","containerWidth","parentElement","addTabInst","handleTabsResize","handleAdd","currentEl","xScrollInst","scrollWidth","scrollTop","scrollHeight","handleScroll","e","triggerRef","tabStyleRef","tabClassRef","addTabStyleRef","addTabClassRef","paneClassRef","paneStyleRef","typeRef","closableRef","valueRef","onBeforeLeaveRef","clsPrefix","shadowStartClass","shadowEndClass","exposedMethods","syncBarPosition","handleSegmentResize","cssVarsRef","typeSuffix","card","bar","line","segment","sizeType","self","barColor","closeIconColor","closeIconColorHover","closeIconColorPressed","tabColor","tabBorderColor","paneTextColor","tabFontWeight","tabBorderRadius","tabFontWeightActive","colorSegment","fontWeightStrong","tabColorSegment","closeSize","closeIconSize","closeColorHover","closeColorPressed","closeBorderRadius","panePadding","tabPadding","tabPaddingVertical","tabGap","tabGapVertical","tabTextColor","tabTextColorActive","tabTextColorHover","tabTextColorDisabled","tabFontSize","common","cubicBezierEaseInOut","themeClassHandle","mergedClsPrefix","mergedValue","renderedNames","Set","addTabFixed","tabWrapperStyle","mergedSize","cssVars","themeClass","animationDirection","onRender","render","$slots","defaultSlot","prefix","prefixSlot","suffix","suffixSlot","tabPaneChildren","filter","v","__TAB_PANE__","tabChildren","__TAB__","showPane","length","isCard","isSegment","mergedJustifyContent","scrollContent","tabs","class","map","tabPaneVNode","index","push","justifyTabDynamicProps","internalCreatedByPane","internalLeftPadded","children","tab","tabVNode","createLeftPaddedTabVNode","createAddTag","onResize","resolvedPlacement","onScroll","filterMapTabPanes","tabPaneVNodes","onEnter","onAfterEnter","forEach","vNode","displayDirective","_displayDirective","matchDisplayDirective","directive","show","key","has","useVShow","internalAddable","modifiedVNode","isArray","dynamicProps"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/naive-ui/es/tabs/src/Tabs.mjs"],"sourcesContent":["import { h, ref, defineComponent, computed, provide, watch, toRef, nextTick, withDirectives, vShow, watchEffect, cloneVNode, TransitionGroup, onMounted } from 'vue';\nimport { VResizeObserver, VXScroll } from 'vueuc';\nimport { throttle } from 'lodash-es';\nimport { useCompitable, onFontsReady, useMergedState } from 'vooks';\nimport { useConfig, useTheme, useThemeClass } from \"../../_mixins/index.mjs\";\nimport { createKey, call, flatten, warnOnce, resolveWrappedSlot } from \"../../_utils/index.mjs\";\nimport { tabsLight } from \"../styles/index.mjs\";\nimport { tabsInjectionKey } from \"./interface.mjs\";\nimport Tab from \"./Tab.mjs\";\nimport style from \"./styles/index.cssr.mjs\";\nimport { depx, getPadding } from 'seemly';\nexport const tabsProps = Object.assign(Object.assign({}, useTheme.props), {\n  value: [String, Number],\n  defaultValue: [String, Number],\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  type: {\n    type: String,\n    default: 'bar'\n  },\n  closable: Boolean,\n  justifyContent: String,\n  size: {\n    type: String,\n    default: 'medium'\n  },\n  placement: {\n    type: String,\n    default: 'top'\n  },\n  tabStyle: [String, Object],\n  tabClass: String,\n  addTabStyle: [String, Object],\n  addTabClass: String,\n  barWidth: Number,\n  paneClass: String,\n  paneStyle: [String, Object],\n  paneWrapperClass: String,\n  paneWrapperStyle: [String, Object],\n  addable: [Boolean, Object],\n  tabsPadding: {\n    type: Number,\n    default: 0\n  },\n  animated: Boolean,\n  onBeforeLeave: Function,\n  onAdd: Function,\n  'onUpdate:value': [Function, Array],\n  onUpdateValue: [Function, Array],\n  onClose: [Function, Array],\n  // deprecated\n  labelSize: String,\n  activeName: [String, Number],\n  onActiveNameChange: [Function, Array]\n});\nexport default defineComponent({\n  name: 'Tabs',\n  props: tabsProps,\n  setup(props, {\n    slots\n  }) {\n    var _a, _b, _c, _d;\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.labelSize !== undefined) {\n          warnOnce('tabs', '`label-size` is deprecated, please use `size` instead.');\n        }\n        if (props.activeName !== undefined) {\n          warnOnce('tabs', '`active-name` is deprecated, please use `value` instead.');\n        }\n        if (props.onActiveNameChange !== undefined) {\n          warnOnce('tabs', '`on-active-name-change` is deprecated, please use `on-update:value` instead.');\n        }\n      });\n    }\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    const themeRef = useTheme('Tabs', '-tabs', style, tabsLight, props, mergedClsPrefixRef);\n    const tabsElRef = ref(null);\n    const barElRef = ref(null);\n    const scrollWrapperElRef = ref(null);\n    const addTabInstRef = ref(null);\n    const xScrollInstRef = ref(null);\n    const yScrollElRef = ref(null);\n    const startReachedRef = ref(true);\n    const endReachedRef = ref(true);\n    const compitableSizeRef = useCompitable(props, ['labelSize', 'size']);\n    const compitableValueRef = useCompitable(props, ['activeName', 'value']);\n    const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);\n    const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);\n    const tabChangeIdRef = {\n      id: 0\n    };\n    const tabWrapperStyleRef = computed(() => {\n      if (!props.justifyContent || props.type === 'card') return undefined;\n      return {\n        display: 'flex',\n        justifyContent: props.justifyContent\n      };\n    });\n    watch(mergedValueRef, () => {\n      tabChangeIdRef.id = 0;\n      updateCurrentBarStyle();\n      updateCurrentScrollPosition(true);\n    });\n    function getCurrentEl() {\n      var _a;\n      const {\n        value\n      } = mergedValueRef;\n      if (value === null) return null;\n      const tabEl = (_a = tabsElRef.value) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-name=\"${value}\"]`);\n      return tabEl;\n    }\n    function updateBarStyle(tabEl) {\n      if (props.type === 'card') return;\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      const barIsHide = barEl.style.opacity === '0';\n      if (tabEl) {\n        const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;\n        const {\n          barWidth,\n          placement\n        } = props;\n        if (tabEl.dataset.disabled === 'true') {\n          barEl.classList.add(disabledClassName);\n        } else {\n          barEl.classList.remove(disabledClassName);\n        }\n        if (['top', 'bottom'].includes(placement)) {\n          clearBarStyle(['top', 'maxHeight', 'height']);\n          if (typeof barWidth === 'number' && tabEl.offsetWidth >= barWidth) {\n            const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;\n            barEl.style.left = `${offsetDiffLeft}px`;\n            barEl.style.maxWidth = `${barWidth}px`;\n          } else {\n            barEl.style.left = `${tabEl.offsetLeft}px`;\n            barEl.style.maxWidth = `${tabEl.offsetWidth}px`;\n          }\n          barEl.style.width = '8192px';\n          if (barIsHide) {\n            barEl.style.transition = 'none';\n          }\n          void barEl.offsetWidth;\n          if (barIsHide) {\n            barEl.style.transition = '';\n            barEl.style.opacity = '1';\n          }\n        } else {\n          clearBarStyle(['left', 'maxWidth', 'width']);\n          if (typeof barWidth === 'number' && tabEl.offsetHeight >= barWidth) {\n            const offsetDiffTop = Math.floor((tabEl.offsetHeight - barWidth) / 2) + tabEl.offsetTop;\n            barEl.style.top = `${offsetDiffTop}px`;\n            barEl.style.maxHeight = `${barWidth}px`;\n          } else {\n            barEl.style.top = `${tabEl.offsetTop}px`;\n            barEl.style.maxHeight = `${tabEl.offsetHeight}px`;\n          }\n          barEl.style.height = '8192px';\n          if (barIsHide) {\n            barEl.style.transition = 'none';\n          }\n          void barEl.offsetHeight;\n          if (barIsHide) {\n            barEl.style.transition = '';\n            barEl.style.opacity = '1';\n          }\n        }\n      }\n    }\n    function hideBarStyle() {\n      if (props.type === 'card') return;\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      barEl.style.opacity = '0';\n    }\n    function clearBarStyle(styleProps) {\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      for (const prop of styleProps) {\n        barEl.style[prop] = '';\n      }\n    }\n    function updateCurrentBarStyle() {\n      if (props.type === 'card') return;\n      const tabEl = getCurrentEl();\n      if (tabEl) {\n        updateBarStyle(tabEl);\n      } else {\n        hideBarStyle();\n      }\n    }\n    function updateCurrentScrollPosition(smooth) {\n      var _a;\n      const scrollWrapperEl = (_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;\n      if (!scrollWrapperEl) return;\n      const tabEl = getCurrentEl();\n      if (!tabEl) return;\n      const {\n        scrollLeft: scrollWrapperElScrollLeft,\n        offsetWidth: scrollWrapperElOffsetWidth\n      } = scrollWrapperEl;\n      const {\n        offsetLeft: tabElOffsetLeft,\n        offsetWidth: tabElOffsetWidth\n      } = tabEl;\n      if (scrollWrapperElScrollLeft > tabElOffsetLeft) {\n        scrollWrapperEl.scrollTo({\n          top: 0,\n          left: tabElOffsetLeft,\n          behavior: 'smooth'\n        });\n      } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {\n        scrollWrapperEl.scrollTo({\n          top: 0,\n          left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,\n          behavior: 'smooth'\n        });\n      }\n    }\n    const tabsPaneWrapperRef = ref(null);\n    let fromHeight = 0;\n    let hangingTransition = null;\n    function onAnimationBeforeLeave(el) {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        fromHeight = el.getBoundingClientRect().height;\n        const fromHeightPx = `${fromHeight}px`;\n        const applyFromStyle = () => {\n          tabsPaneWrapperEl.style.height = fromHeightPx;\n          tabsPaneWrapperEl.style.maxHeight = fromHeightPx;\n        };\n        if (!hangingTransition) {\n          hangingTransition = applyFromStyle;\n        } else {\n          applyFromStyle();\n          hangingTransition();\n          hangingTransition = null;\n        }\n      }\n    }\n    function onAnimationEnter(el) {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        const targetHeight = el.getBoundingClientRect().height;\n        const applyTargetStyle = () => {\n          void document.body.offsetHeight;\n          tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;\n          tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;\n        };\n        if (!hangingTransition) {\n          hangingTransition = applyTargetStyle;\n        } else {\n          hangingTransition();\n          hangingTransition = null;\n          applyTargetStyle();\n        }\n      }\n    }\n    function onAnimationAfterEnter() {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        tabsPaneWrapperEl.style.maxHeight = '';\n        tabsPaneWrapperEl.style.height = '';\n        const {\n          paneWrapperStyle\n        } = props;\n        if (typeof paneWrapperStyle === 'string') {\n          tabsPaneWrapperEl.style.cssText = paneWrapperStyle;\n        } else if (paneWrapperStyle) {\n          const {\n            maxHeight,\n            height\n          } = paneWrapperStyle;\n          if (maxHeight !== undefined) {\n            tabsPaneWrapperEl.style.maxHeight = maxHeight;\n          }\n          if (height !== undefined) {\n            tabsPaneWrapperEl.style.height = height;\n          }\n        }\n      }\n    }\n    const renderNameListRef = {\n      value: []\n    };\n    const animationDirectionRef = ref('next');\n    function activateTab(panelName) {\n      const currentValue = mergedValueRef.value;\n      let dir = 'next';\n      for (const name of renderNameListRef.value) {\n        if (name === currentValue) {\n          break;\n        }\n        if (name === panelName) {\n          dir = 'prev';\n          break;\n        }\n      }\n      animationDirectionRef.value = dir;\n      doUpdateValue(panelName);\n    }\n    function doUpdateValue(panelName) {\n      const {\n        onActiveNameChange,\n        onUpdateValue,\n        'onUpdate:value': _onUpdateValue\n      } = props;\n      if (onActiveNameChange) {\n        call(onActiveNameChange, panelName);\n      }\n      if (onUpdateValue) call(onUpdateValue, panelName);\n      if (_onUpdateValue) call(_onUpdateValue, panelName);\n      uncontrolledValueRef.value = panelName;\n    }\n    function handleClose(panelName) {\n      const {\n        onClose\n      } = props;\n      if (onClose) call(onClose, panelName);\n    }\n    let firstTimeUpdatePosition = true;\n    function updateBarPositionInstantly() {\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      if (!firstTimeUpdatePosition) firstTimeUpdatePosition = false;\n      const disableTransitionClassName = 'transition-disabled';\n      barEl.classList.add(disableTransitionClassName);\n      updateCurrentBarStyle();\n      // here we don't need to force layout after update bar style\n      // since deriveScrollShadow will force layout\n      barEl.classList.remove(disableTransitionClassName);\n    }\n    const segmentCapsuleElRef = ref(null);\n    function updateSegmentPosition({\n      transitionDisabled\n    }) {\n      const tabsEl = tabsElRef.value;\n      if (!tabsEl) return;\n      transitionDisabled && tabsEl.classList.add('transition-disabled');\n      const activeTabEl = getCurrentEl();\n      if (activeTabEl && segmentCapsuleElRef.value) {\n        // move segment capsule to match the position of the active tab\n        segmentCapsuleElRef.value.style.width = `${activeTabEl.offsetWidth}px`;\n        segmentCapsuleElRef.value.style.height = `${activeTabEl.offsetHeight}px`;\n        segmentCapsuleElRef.value.style.transform = `translateX(${activeTabEl.offsetLeft - depx(getComputedStyle(tabsEl).paddingLeft)}px)`;\n        if (transitionDisabled) {\n          void segmentCapsuleElRef.value.offsetWidth;\n        }\n      }\n      transitionDisabled && tabsEl.classList.remove('transition-disabled');\n    }\n    watch([mergedValueRef], () => {\n      if (props.type === 'segment') {\n        void nextTick(() => {\n          updateSegmentPosition({\n            transitionDisabled: false\n          });\n        });\n      }\n    });\n    onMounted(() => {\n      if (props.type === 'segment') {\n        updateSegmentPosition({\n          transitionDisabled: true\n        });\n      }\n    });\n    let memorizedWidth = 0;\n    function _handleNavResize(entry) {\n      var _a, _b;\n      if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {\n        return;\n      }\n      if (memorizedWidth === entry.contentRect.width) {\n        return;\n      }\n      memorizedWidth = entry.contentRect.width;\n      const {\n        type\n      } = props;\n      if (type === 'line' || type === 'bar') {\n        if (firstTimeUpdatePosition || ((_a = props.justifyContent) === null || _a === void 0 ? void 0 : _a.startsWith('space'))) {\n          updateBarPositionInstantly();\n        }\n      }\n      if (type !== 'segment') {\n        const {\n          placement\n        } = props;\n        deriveScrollShadow((placement === 'top' || placement === 'bottom' ? (_b = xScrollInstRef.value) === null || _b === void 0 ? void 0 : _b.$el : yScrollElRef.value) || null);\n      }\n    }\n    const handleNavResize = throttle(_handleNavResize, 64);\n    watch([() => props.justifyContent, () => props.size], () => {\n      void nextTick(() => {\n        const {\n          type\n        } = props;\n        if (type === 'line' || type === 'bar') {\n          updateBarPositionInstantly();\n        }\n      });\n    });\n    const addTabFixedRef = ref(false);\n    function _handleTabsResize(entry) {\n      var _a;\n      const {\n        target,\n        contentRect: {\n          width\n        }\n      } = entry;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const containerWidth = target.parentElement.offsetWidth;\n      if (!addTabFixedRef.value) {\n        if (containerWidth < width) {\n          addTabFixedRef.value = true;\n        }\n      } else {\n        const {\n          value: addTabInst\n        } = addTabInstRef;\n        if (!addTabInst) return;\n        if (containerWidth - width > addTabInst.$el.offsetWidth) {\n          addTabFixedRef.value = false;\n        }\n      }\n      deriveScrollShadow(((_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) || null);\n    }\n    const handleTabsResize = throttle(_handleTabsResize, 64);\n    function handleAdd() {\n      const {\n        onAdd\n      } = props;\n      if (onAdd) onAdd();\n      void nextTick(() => {\n        const currentEl = getCurrentEl();\n        const {\n          value: xScrollInst\n        } = xScrollInstRef;\n        if (!currentEl || !xScrollInst) return;\n        xScrollInst.scrollTo({\n          left: currentEl.offsetLeft,\n          top: 0,\n          behavior: 'smooth'\n        });\n      });\n    }\n    function deriveScrollShadow(el) {\n      if (!el) return;\n      const {\n        placement\n      } = props;\n      if (placement === 'top' || placement === 'bottom') {\n        const {\n          scrollLeft,\n          scrollWidth,\n          offsetWidth\n        } = el;\n        startReachedRef.value = scrollLeft <= 0;\n        endReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;\n      } else {\n        const {\n          scrollTop,\n          scrollHeight,\n          offsetHeight\n        } = el;\n        startReachedRef.value = scrollTop <= 0;\n        endReachedRef.value = scrollTop + offsetHeight >= scrollHeight;\n      }\n    }\n    const handleScroll = throttle(e => {\n      deriveScrollShadow(e.target);\n    }, 64);\n    provide(tabsInjectionKey, {\n      triggerRef: toRef(props, 'trigger'),\n      tabStyleRef: toRef(props, 'tabStyle'),\n      tabClassRef: toRef(props, 'tabClass'),\n      addTabStyleRef: toRef(props, 'addTabStyle'),\n      addTabClassRef: toRef(props, 'addTabClass'),\n      paneClassRef: toRef(props, 'paneClass'),\n      paneStyleRef: toRef(props, 'paneStyle'),\n      mergedClsPrefixRef,\n      typeRef: toRef(props, 'type'),\n      closableRef: toRef(props, 'closable'),\n      valueRef: mergedValueRef,\n      tabChangeIdRef,\n      onBeforeLeaveRef: toRef(props, 'onBeforeLeave'),\n      activateTab,\n      handleClose,\n      handleAdd\n    });\n    onFontsReady(() => {\n      updateCurrentBarStyle();\n      updateCurrentScrollPosition(true);\n    });\n    // avoid useless rerender\n    watchEffect(() => {\n      const {\n        value: el\n      } = scrollWrapperElRef;\n      if (!el) return;\n      const {\n        value: clsPrefix\n      } = mergedClsPrefixRef;\n      const shadowStartClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-start`;\n      const shadowEndClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-end`;\n      if (startReachedRef.value) {\n        el.classList.remove(shadowStartClass);\n      } else {\n        el.classList.add(shadowStartClass);\n      }\n      if (endReachedRef.value) {\n        el.classList.remove(shadowEndClass);\n      } else {\n        el.classList.add(shadowEndClass);\n      }\n    });\n    const exposedMethods = {\n      syncBarPosition: () => {\n        updateCurrentBarStyle();\n      }\n    };\n    const handleSegmentResize = () => {\n      updateSegmentPosition({\n        transitionDisabled: true\n      });\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        value: size\n      } = compitableSizeRef;\n      const {\n        type\n      } = props;\n      const typeSuffix = {\n        card: 'Card',\n        bar: 'Bar',\n        line: 'Line',\n        segment: 'Segment'\n      }[type];\n      const sizeType = `${size}${typeSuffix}`;\n      const {\n        self: {\n          barColor,\n          closeIconColor,\n          closeIconColorHover,\n          closeIconColorPressed,\n          tabColor,\n          tabBorderColor,\n          paneTextColor,\n          tabFontWeight,\n          tabBorderRadius,\n          tabFontWeightActive,\n          colorSegment,\n          fontWeightStrong,\n          tabColorSegment,\n          closeSize,\n          closeIconSize,\n          closeColorHover,\n          closeColorPressed,\n          closeBorderRadius,\n          [createKey('panePadding', size)]: panePadding,\n          [createKey('tabPadding', sizeType)]: tabPadding,\n          [createKey('tabPaddingVertical', sizeType)]: tabPaddingVertical,\n          [createKey('tabGap', sizeType)]: tabGap,\n          [createKey('tabGap', `${sizeType}Vertical`)]: tabGapVertical,\n          [createKey('tabTextColor', type)]: tabTextColor,\n          [createKey('tabTextColorActive', type)]: tabTextColorActive,\n          [createKey('tabTextColorHover', type)]: tabTextColorHover,\n          [createKey('tabTextColorDisabled', type)]: tabTextColorDisabled,\n          [createKey('tabFontSize', size)]: tabFontSize\n        },\n        common: {\n          cubicBezierEaseInOut\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-color-segment': colorSegment,\n        '--n-bar-color': barColor,\n        '--n-tab-font-size': tabFontSize,\n        '--n-tab-text-color': tabTextColor,\n        '--n-tab-text-color-active': tabTextColorActive,\n        '--n-tab-text-color-disabled': tabTextColorDisabled,\n        '--n-tab-text-color-hover': tabTextColorHover,\n        '--n-pane-text-color': paneTextColor,\n        '--n-tab-border-color': tabBorderColor,\n        '--n-tab-border-radius': tabBorderRadius,\n        '--n-close-size': closeSize,\n        '--n-close-icon-size': closeIconSize,\n        '--n-close-color-hover': closeColorHover,\n        '--n-close-color-pressed': closeColorPressed,\n        '--n-close-border-radius': closeBorderRadius,\n        '--n-close-icon-color': closeIconColor,\n        '--n-close-icon-color-hover': closeIconColorHover,\n        '--n-close-icon-color-pressed': closeIconColorPressed,\n        '--n-tab-color': tabColor,\n        '--n-tab-font-weight': tabFontWeight,\n        '--n-tab-font-weight-active': tabFontWeightActive,\n        '--n-tab-padding': tabPadding,\n        '--n-tab-padding-vertical': tabPaddingVertical,\n        '--n-tab-gap': tabGap,\n        '--n-tab-gap-vertical': tabGapVertical,\n        '--n-pane-padding-left': getPadding(panePadding, 'left'),\n        '--n-pane-padding-right': getPadding(panePadding, 'right'),\n        '--n-pane-padding-top': getPadding(panePadding, 'top'),\n        '--n-pane-padding-bottom': getPadding(panePadding, 'bottom'),\n        '--n-font-weight-strong': fontWeightStrong,\n        '--n-tab-color-segment': tabColorSegment\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tabs', computed(() => {\n      return `${compitableSizeRef.value[0]}${props.type[0]}`;\n    }), cssVarsRef, props) : undefined;\n    return Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedValue: mergedValueRef,\n      renderedNames: new Set(),\n      segmentCapsuleElRef,\n      tabsPaneWrapperRef,\n      tabsElRef,\n      barElRef,\n      addTabInstRef,\n      xScrollInstRef,\n      scrollWrapperElRef,\n      addTabFixed: addTabFixedRef,\n      tabWrapperStyle: tabWrapperStyleRef,\n      handleNavResize,\n      mergedSize: compitableSizeRef,\n      handleScroll,\n      handleTabsResize,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      animationDirection: animationDirectionRef,\n      renderNameListRef,\n      yScrollElRef,\n      handleSegmentResize,\n      onAnimationBeforeLeave,\n      onAnimationEnter,\n      onAnimationAfterEnter,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    }, exposedMethods);\n  },\n  render() {\n    const {\n      mergedClsPrefix,\n      type,\n      placement,\n      addTabFixed,\n      addable,\n      mergedSize,\n      renderNameListRef,\n      onRender,\n      paneWrapperClass,\n      paneWrapperStyle,\n      $slots: {\n        default: defaultSlot,\n        prefix: prefixSlot,\n        suffix: suffixSlot\n      }\n    } = this;\n    onRender === null || onRender === void 0 ? void 0 : onRender();\n    const tabPaneChildren = defaultSlot ? flatten(defaultSlot()).filter(v => {\n      return v.type.__TAB_PANE__ === true;\n    }) : [];\n    const tabChildren = defaultSlot ? flatten(defaultSlot()).filter(v => {\n      return v.type.__TAB__ === true;\n    }) : [];\n    const showPane = !tabChildren.length;\n    const isCard = type === 'card';\n    const isSegment = type === 'segment';\n    const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;\n    renderNameListRef.value = [];\n    const scrollContent = () => {\n      const tabs = h(\"div\", {\n        style: this.tabWrapperStyle,\n        class: [`${mergedClsPrefix}-tabs-wrapper`]\n      }, mergedJustifyContent ? null : h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-scroll-padding`,\n        style: {\n          width: `${this.tabsPadding}px`\n        }\n      }), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {\n        renderNameListRef.value.push(tabPaneVNode.props.name);\n        return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, {\n          internalCreatedByPane: true,\n          internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === 'center' || mergedJustifyContent === 'start' || mergedJustifyContent === 'end')\n        }), tabPaneVNode.children ? {\n          default: tabPaneVNode.children.tab\n        } : undefined));\n      }) : tabChildren.map((tabVNode, index) => {\n        renderNameListRef.value.push(tabVNode.props.name);\n        if (index !== 0 && !mergedJustifyContent) {\n          return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));\n        } else {\n          return justifyTabDynamicProps(tabVNode);\n        }\n      }), !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null, mergedJustifyContent ? null : h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-scroll-padding`,\n        style: {\n          width: `${this.tabsPadding}px`\n        }\n      }));\n      return h(\"div\", {\n        ref: \"tabsElRef\",\n        class: `${mergedClsPrefix}-tabs-nav-scroll-content`\n      }, isCard && addable ? h(VResizeObserver, {\n        onResize: this.handleTabsResize\n      }, {\n        default: () => tabs\n      }) : tabs, isCard ? h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-pad`\n      }) : null, isCard ? null : h(\"div\", {\n        ref: \"barElRef\",\n        class: `${mergedClsPrefix}-tabs-bar`\n      }));\n    };\n    const resolvedPlacement = isSegment ? 'top' : placement;\n    return h(\"div\", {\n      class: [`${mergedClsPrefix}-tabs`, this.themeClass, `${mergedClsPrefix}-tabs--${type}-type`, `${mergedClsPrefix}-tabs--${mergedSize}-size`, mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`, `${mergedClsPrefix}-tabs--${resolvedPlacement}`],\n      style: this.cssVars\n    }, h(\"div\", {\n      class: [\n      // the class should be applied here since it's possible\n      // to make tabs nested in tabs, style may influence each\n      // other. adding a class will make it easy to write the\n      // style.\n      `${mergedClsPrefix}-tabs-nav--${type}-type`, `${mergedClsPrefix}-tabs-nav--${resolvedPlacement}`, `${mergedClsPrefix}-tabs-nav`]\n    }, resolveWrappedSlot(prefixSlot, children => children && h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-nav__prefix`\n    }, children)), isSegment ? h(VResizeObserver, {\n      onResize: this.handleSegmentResize\n    }, {\n      default: () => h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-rail`,\n        ref: \"tabsElRef\"\n      }, h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-capsule`,\n        ref: \"segmentCapsuleElRef\"\n      }, h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-wrapper`\n      }, h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-tab`\n      }))), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {\n        renderNameListRef.value.push(tabPaneVNode.props.name);\n        return h(Tab, Object.assign({}, tabPaneVNode.props, {\n          internalCreatedByPane: true,\n          internalLeftPadded: index !== 0\n        }), tabPaneVNode.children ? {\n          default: tabPaneVNode.children.tab\n        } : undefined);\n      }) : tabChildren.map((tabVNode, index) => {\n        renderNameListRef.value.push(tabVNode.props.name);\n        if (index === 0) {\n          return tabVNode;\n        } else {\n          return createLeftPaddedTabVNode(tabVNode);\n        }\n      }))\n    }) : h(VResizeObserver, {\n      onResize: this.handleNavResize\n    }, {\n      default: () => h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`,\n        ref: \"scrollWrapperElRef\"\n      }, ['top', 'bottom'].includes(resolvedPlacement) ? h(VXScroll, {\n        ref: \"xScrollInstRef\",\n        onScroll: this.handleScroll\n      }, {\n        default: scrollContent\n      }) : h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-nav-y-scroll`,\n        onScroll: this.handleScroll,\n        ref: \"yScrollElRef\"\n      }, scrollContent()))\n    }), addTabFixed && addable && isCard ? createAddTag(addable, true) : null, resolveWrappedSlot(suffixSlot, children => children && h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-nav__suffix`\n    }, children))), showPane && (this.animated && (resolvedPlacement === 'top' || resolvedPlacement === 'bottom') ? h(\"div\", {\n      ref: \"tabsPaneWrapperRef\",\n      style: paneWrapperStyle,\n      class: [`${mergedClsPrefix}-tabs-pane-wrapper`, paneWrapperClass]\n    }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)));\n  }\n});\nfunction filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {\n  const children = [];\n  tabPaneVNodes.forEach(vNode => {\n    const {\n      name,\n      displayDirective,\n      'display-directive': _displayDirective\n    } = vNode.props;\n    const matchDisplayDirective = directive => displayDirective === directive || _displayDirective === directive;\n    const show = value === name;\n    if (vNode.key !== undefined) {\n      vNode.key = name;\n    }\n    if (show || matchDisplayDirective('show') || matchDisplayDirective('show:lazy') && renderedNames.has(name)) {\n      if (!renderedNames.has(name)) {\n        renderedNames.add(name);\n      }\n      const useVShow = !matchDisplayDirective('if');\n      children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);\n    }\n  });\n  if (!animationDirection) {\n    return children;\n  }\n  return h(TransitionGroup, {\n    name: `${animationDirection}-transition`,\n    onBeforeLeave: onBeforeLeave,\n    onEnter: onEnter,\n    onAfterEnter: onAfterEnter\n  }, {\n    default: () => children\n  });\n}\nfunction createAddTag(addable, internalLeftPadded) {\n  return h(Tab, {\n    ref: \"addTabInstRef\",\n    key: \"__addable\",\n    name: \"__addable\",\n    internalCreatedByPane: true,\n    internalAddable: true,\n    internalLeftPadded: internalLeftPadded,\n    disabled: typeof addable === 'object' && addable.disabled\n  });\n}\nfunction createLeftPaddedTabVNode(tabVNode) {\n  const modifiedVNode = cloneVNode(tabVNode);\n  if (modifiedVNode.props) {\n    modifiedVNode.props.internalLeftPadded = true;\n  } else {\n    modifiedVNode.props = {\n      internalLeftPadded: true\n    };\n  }\n  return modifiedVNode;\n}\nfunction justifyTabDynamicProps(tabVNode) {\n  if (Array.isArray(tabVNode.dynamicProps)) {\n    if (!tabVNode.dynamicProps.includes('internalLeftPadded')) {\n      tabVNode.dynamicProps.push('internalLeftPadded');\n    }\n  } else {\n    tabVNode.dynamicProps = ['internalLeftPadded'];\n  }\n  return tabVNode;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}