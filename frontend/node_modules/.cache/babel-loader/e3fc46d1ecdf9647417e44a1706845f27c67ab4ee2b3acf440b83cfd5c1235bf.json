{"ast":null,"code":"import \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nexport const resolveOptionsAndHash = (options = {}) => {\n  var _a;\n  const {\n    root = null\n  } = options;\n  return {\n    hash: `${options.rootMargin || '0px 0px 0px 0px'}-${Array.isArray(options.threshold) ? options.threshold.join(',') : (_a = options.threshold) !== null && _a !== void 0 ? _a : '0'}`,\n    options: Object.assign(Object.assign({}, options), {\n      root: (typeof root === 'string' ? document.querySelector(root) : root) || document.documentElement\n    })\n  };\n};\n// root -> options -> [observer, elements]\nconst observers = new WeakMap();\nconst unobserveHandleMap = new WeakMap();\nconst shouldStartLoadingRefMap = new WeakMap();\nexport const observeIntersection = (el, options, shouldStartLoadingRef) => {\n  if (!el) return () => {};\n  const resolvedOptionsAndHash = resolveOptionsAndHash(options);\n  const {\n    root\n  } = resolvedOptionsAndHash.options;\n  let rootObservers;\n  const _rootObservers = observers.get(root);\n  if (_rootObservers) {\n    rootObservers = _rootObservers;\n  } else {\n    rootObservers = new Map();\n    observers.set(root, rootObservers);\n  }\n  let observer;\n  let observerAndObservedElements;\n  if (rootObservers.has(resolvedOptionsAndHash.hash)) {\n    observerAndObservedElements =\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    rootObservers.get(resolvedOptionsAndHash.hash);\n    if (!observerAndObservedElements[1].has(el)) {\n      observer = observerAndObservedElements[0];\n      observerAndObservedElements[1].add(el);\n      observer.observe(el);\n    }\n  } else {\n    observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const _unobserve = unobserveHandleMap.get(entry.target);\n          const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);\n          if (_unobserve) _unobserve();\n          if (_shouldStartLoadingRef) {\n            _shouldStartLoadingRef.value = true;\n          }\n        }\n      });\n    }, resolvedOptionsAndHash.options);\n    observer.observe(el);\n    observerAndObservedElements = [observer, new Set([el])];\n    rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);\n  }\n  let unobservered = false;\n  const unobserve = () => {\n    if (unobservered) return;\n    unobserveHandleMap.delete(el);\n    shouldStartLoadingRefMap.delete(el);\n    unobservered = true;\n    if (observerAndObservedElements[1].has(el)) {\n      observerAndObservedElements[0].unobserve(el);\n      observerAndObservedElements[1].delete(el);\n    }\n    if (observerAndObservedElements[1].size <= 0) {\n      rootObservers.delete(resolvedOptionsAndHash.hash);\n    }\n    if (!rootObservers.size) {\n      observers.delete(root);\n    }\n  };\n  unobserveHandleMap.set(el, unobserve);\n  shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);\n  return unobserve;\n};","map":{"version":3,"names":["resolveOptionsAndHash","options","_a","root","hash","rootMargin","Array","isArray","threshold","join","Object","assign","document","querySelector","documentElement","observers","WeakMap","unobserveHandleMap","shouldStartLoadingRefMap","observeIntersection","el","shouldStartLoadingRef","resolvedOptionsAndHash","rootObservers","_rootObservers","get","Map","set","observer","observerAndObservedElements","has","add","observe","IntersectionObserver","entries","forEach","entry","isIntersecting","_unobserve","target","_shouldStartLoadingRef","value","Set","unobservered","unobserve","delete","size"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/naive-ui/es/image/src/utils.mjs"],"sourcesContent":["export const resolveOptionsAndHash = (options = {}) => {\n  var _a;\n  const {\n    root = null\n  } = options;\n  return {\n    hash: `${options.rootMargin || '0px 0px 0px 0px'}-${Array.isArray(options.threshold) ? options.threshold.join(',') : (_a = options.threshold) !== null && _a !== void 0 ? _a : '0'}`,\n    options: Object.assign(Object.assign({}, options), {\n      root: (typeof root === 'string' ? document.querySelector(root) : root) || document.documentElement\n    })\n  };\n};\n// root -> options -> [observer, elements]\nconst observers = new WeakMap();\nconst unobserveHandleMap = new WeakMap();\nconst shouldStartLoadingRefMap = new WeakMap();\nexport const observeIntersection = (el, options, shouldStartLoadingRef) => {\n  if (!el) return () => {};\n  const resolvedOptionsAndHash = resolveOptionsAndHash(options);\n  const {\n    root\n  } = resolvedOptionsAndHash.options;\n  let rootObservers;\n  const _rootObservers = observers.get(root);\n  if (_rootObservers) {\n    rootObservers = _rootObservers;\n  } else {\n    rootObservers = new Map();\n    observers.set(root, rootObservers);\n  }\n  let observer;\n  let observerAndObservedElements;\n  if (rootObservers.has(resolvedOptionsAndHash.hash)) {\n    observerAndObservedElements =\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    rootObservers.get(resolvedOptionsAndHash.hash);\n    if (!observerAndObservedElements[1].has(el)) {\n      observer = observerAndObservedElements[0];\n      observerAndObservedElements[1].add(el);\n      observer.observe(el);\n    }\n  } else {\n    observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const _unobserve = unobserveHandleMap.get(entry.target);\n          const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);\n          if (_unobserve) _unobserve();\n          if (_shouldStartLoadingRef) {\n            _shouldStartLoadingRef.value = true;\n          }\n        }\n      });\n    }, resolvedOptionsAndHash.options);\n    observer.observe(el);\n    observerAndObservedElements = [observer, new Set([el])];\n    rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);\n  }\n  let unobservered = false;\n  const unobserve = () => {\n    if (unobservered) return;\n    unobserveHandleMap.delete(el);\n    shouldStartLoadingRefMap.delete(el);\n    unobservered = true;\n    if (observerAndObservedElements[1].has(el)) {\n      observerAndObservedElements[0].unobserve(el);\n      observerAndObservedElements[1].delete(el);\n    }\n    if (observerAndObservedElements[1].size <= 0) {\n      rootObservers.delete(resolvedOptionsAndHash.hash);\n    }\n    if (!rootObservers.size) {\n      observers.delete(root);\n    }\n  };\n  unobserveHandleMap.set(el, unobserve);\n  shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);\n  return unobserve;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}