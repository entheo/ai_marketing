{"ast":null,"code":"import tzTokenizeDate from '../tzTokenizeDate/index.js';\nimport newDateUTC from '../newDateUTC/index.js';\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE = 60000;\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-]\\d{2})$/,\n  timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/\n};\n\n// Parse various time zone offset formats to an offset in milliseconds\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token;\n  var absoluteOffset;\n\n  // Empty string\n  if (!timezoneString) {\n    return 0;\n  }\n\n  // Z\n  token = patterns.timezoneZ.exec(timezoneString);\n  if (token) {\n    return 0;\n  }\n  var hours;\n\n  // ±hh\n  token = patterns.timezoneHH.exec(timezoneString);\n  if (token) {\n    hours = parseInt(token[1], 10);\n    if (!validateTimezone(hours)) {\n      return NaN;\n    }\n    return -(hours * MILLISECONDS_IN_HOUR);\n  }\n\n  // ±hh:mm or ±hhmm\n  token = patterns.timezoneHHMM.exec(timezoneString);\n  if (token) {\n    hours = parseInt(token[2], 10);\n    var minutes = parseInt(token[3], 10);\n    if (!validateTimezone(hours, minutes)) {\n      return NaN;\n    }\n    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n  }\n\n  // IANA time zone\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now());\n    var utcDate = isUtcDate ? date : toUtcDate(date);\n    var offset = calcOffset(utcDate, timezoneString);\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);\n    return -fixedOffset;\n  }\n  return NaN;\n}\nfunction toUtcDate(date) {\n  return newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\nfunction calcOffset(date, timezoneString) {\n  var tokens = tzTokenizeDate(date, timezoneString);\n\n  // ms dropped because it's not provided by tzTokenizeDate\n  var asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();\n  var asTS = date.getTime();\n  var over = asTS % 1000;\n  asTS -= over >= 0 ? over : 1000 + over;\n  return asUTC - asTS;\n}\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime();\n\n  // Our UTC time is just a guess because our offset is just a guess\n  var utcGuess = localTS - offset;\n\n  // Test whether the zone matches the offset for this ts\n  var o2 = calcOffset(new Date(utcGuess), timezoneString);\n\n  // If so, offset didn't change, and we're done\n  if (offset === o2) {\n    return offset;\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= o2 - offset;\n\n  // If that gives us the local time we want, we're done\n  var o3 = calcOffset(new Date(utcGuess), timezoneString);\n  if (o2 === o3) {\n    return o2;\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\n  return Math.max(o2, o3);\n}\nfunction validateTimezone(hours, minutes) {\n  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);\n}\nvar validIANATimezoneCache = {};\nfunction isValidTimezoneIANAString(timeZoneString) {\n  if (validIANATimezoneCache[timeZoneString]) return true;\n  try {\n    new Intl.DateTimeFormat(undefined, {\n      timeZone: timeZoneString\n    });\n    validIANATimezoneCache[timeZoneString] = true;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}","map":{"version":3,"names":["tzTokenizeDate","newDateUTC","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","patterns","timezone","timezoneZ","timezoneHH","timezoneHHMM","tzParseTimezone","timezoneString","date","isUtcDate","token","absoluteOffset","exec","hours","parseInt","validateTimezone","NaN","minutes","Math","abs","isValidTimezoneIANAString","Date","now","utcDate","toUtcDate","offset","calcOffset","fixedOffset","fixOffset","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","tokens","asUTC","getTime","asTS","over","localTS","utcGuess","o2","o3","max","validIANATimezoneCache","timeZoneString","Intl","DateTimeFormat","undefined","timeZone","error"],"sources":["/Users/wangjohnson/ai_marketing/frontend/node_modules/date-fns-tz/esm/_lib/tzParseTimezone/index.js"],"sourcesContent":["import tzTokenizeDate from '../tzTokenizeDate/index.js'\r\nimport newDateUTC from '../newDateUTC/index.js'\r\n\r\nvar MILLISECONDS_IN_HOUR = 3600000\r\nvar MILLISECONDS_IN_MINUTE = 60000\r\n\r\nvar patterns = {\r\n  timezone: /([Z+-].*)$/,\r\n  timezoneZ: /^(Z)$/,\r\n  timezoneHH: /^([+-]\\d{2})$/,\r\n  timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/,\r\n}\r\n\r\n// Parse various time zone offset formats to an offset in milliseconds\r\nexport default function tzParseTimezone(timezoneString, date, isUtcDate) {\r\n  var token\r\n  var absoluteOffset\r\n\r\n  // Empty string\r\n  if (!timezoneString) {\r\n    return 0\r\n  }\r\n\r\n  // Z\r\n  token = patterns.timezoneZ.exec(timezoneString)\r\n  if (token) {\r\n    return 0\r\n  }\r\n\r\n  var hours\r\n\r\n  // ±hh\r\n  token = patterns.timezoneHH.exec(timezoneString)\r\n  if (token) {\r\n    hours = parseInt(token[1], 10)\r\n\r\n    if (!validateTimezone(hours)) {\r\n      return NaN\r\n    }\r\n\r\n    return -(hours * MILLISECONDS_IN_HOUR)\r\n  }\r\n\r\n  // ±hh:mm or ±hhmm\r\n  token = patterns.timezoneHHMM.exec(timezoneString)\r\n  if (token) {\r\n    hours = parseInt(token[2], 10)\r\n    var minutes = parseInt(token[3], 10)\r\n\r\n    if (!validateTimezone(hours, minutes)) {\r\n      return NaN\r\n    }\r\n\r\n    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE\r\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset\r\n  }\r\n\r\n  // IANA time zone\r\n  if (isValidTimezoneIANAString(timezoneString)) {\r\n    date = new Date(date || Date.now())\r\n    var utcDate = isUtcDate ? date : toUtcDate(date)\r\n\r\n    var offset = calcOffset(utcDate, timezoneString)\r\n\r\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString)\r\n\r\n    return -fixedOffset\r\n  }\r\n\r\n  return NaN\r\n}\r\n\r\nfunction toUtcDate(date) {\r\n  return newDateUTC(\r\n    date.getFullYear(),\r\n    date.getMonth(),\r\n    date.getDate(),\r\n    date.getHours(),\r\n    date.getMinutes(),\r\n    date.getSeconds(),\r\n    date.getMilliseconds()\r\n  )\r\n}\r\n\r\nfunction calcOffset(date, timezoneString) {\r\n  var tokens = tzTokenizeDate(date, timezoneString)\r\n\r\n  // ms dropped because it's not provided by tzTokenizeDate\r\n  var asUTC = newDateUTC(\r\n    tokens[0],\r\n    tokens[1] - 1,\r\n    tokens[2],\r\n    tokens[3] % 24,\r\n    tokens[4],\r\n    tokens[5],\r\n    0\r\n  ).getTime()\r\n\r\n  var asTS = date.getTime()\r\n  var over = asTS % 1000\r\n  asTS -= over >= 0 ? over : 1000 + over\r\n  return asUTC - asTS\r\n}\r\n\r\nfunction fixOffset(date, offset, timezoneString) {\r\n  var localTS = date.getTime()\r\n\r\n  // Our UTC time is just a guess because our offset is just a guess\r\n  var utcGuess = localTS - offset\r\n\r\n  // Test whether the zone matches the offset for this ts\r\n  var o2 = calcOffset(new Date(utcGuess), timezoneString)\r\n\r\n  // If so, offset didn't change, and we're done\r\n  if (offset === o2) {\r\n    return offset\r\n  }\r\n\r\n  // If not, change the ts by the difference in the offset\r\n  utcGuess -= o2 - offset\r\n\r\n  // If that gives us the local time we want, we're done\r\n  var o3 = calcOffset(new Date(utcGuess), timezoneString)\r\n  if (o2 === o3) {\r\n    return o2\r\n  }\r\n\r\n  // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\r\n  return Math.max(o2, o3)\r\n}\r\n\r\nfunction validateTimezone(hours, minutes) {\r\n  return -23 <= hours && hours <= 23 && (minutes == null || (0 <= minutes && minutes <= 59))\r\n}\r\n\r\nvar validIANATimezoneCache = {}\r\nfunction isValidTimezoneIANAString(timeZoneString) {\r\n  if (validIANATimezoneCache[timeZoneString]) return true\r\n  try {\r\n    new Intl.DateTimeFormat(undefined, { timeZone: timeZoneString })\r\n    validIANATimezoneCache[timeZoneString] = true\r\n    return true\r\n  } catch (error) {\r\n    return false\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}